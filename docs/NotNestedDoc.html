<!DOCTYPE html><html>  <head>    <title>HAPI Documentation</title>    <meta charset="UTF-8">    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>    <style>    	#content, html, body {	    height: 100%;	}	#left {	    height: 100%;    	width:25%;    	float: left;    	overflow-y: auto;	}   	#right {	    height: 100%;    	width:75%;    	float: right;    	overflow-y: auto;	}         body {        width: 100%;        margin: 1em auto;        color: #222;        font-family: "Ubuntu", sans-serif;        padding-bottom: 4em;      }      h1 {        font-weight: normal;        border-bottom: 1px solid #aaa;        padding-bottom: 0.5ex;      }      h2 {        border-bottom: 1px solid #aaa;        padding-bottom: 0.5ex;        margin: 1.5em 0;      }      h3 {        font-weight: normal;        border-bottom: 1px solid #aaa;        padding-bottom: 0.5ex;      }      a {        text-decoration: none;        color: #0645AD;      }      p { /* Comments */        color: #567e25;      }      table {        width: 100%;        font-size: 95%;        border-collapse: collapse;      }      thead {        font-weight: 700;        background-color: #dcdcdc;      }      tbody tr:nth-child(even) {        background-color: #fbfbfb;      }      td {        border: 1px solid #ccc;        padding: 0.5ex 2ex;      }      td p {        text-indent: 1em;        margin: 0;      }      td p:nth-child(1) {        text-indent: 0; /* No indent on first p in td */      }      /* Table of fields */      .field-table td:nth-child(1) { /* Field */        width: 10em;      }      .field-table td:nth-child(2) { /* Type */        width: 10em;      }      .field-table td:nth-child(3) { /* Label */        width: 6em;      }      .field-table td:nth-child(4) { /* Description */        width: auto;      }      /* Table of extensions */      .extension-table td:nth-child(1) { /* Extension */        width: 10em;      }      .extension-table td:nth-child(2) { /* Type */        width: 10em;      }      .extension-table td:nth-child(3) { /* Base */        width: 10em;      }      .extension-table td:nth-child(4) { /* Number */        width: 5em;      }      .extension-table td:nth-child(5) { /* Description */        width: auto;      }      /* Table of enum values. */      .enum-table td:nth-child(1) { /* Name */        width: 10em;      }      .enum-table td:nth-child(2) { /* Number */        width: 10em;      }      .enum-table td:nth-child(3) { /* Description */        width: auto;      }      /* Table of scalar value types. */      .scalar-value-types-table tr {        height: 3em;      }      /* Table of contents. */      #toc-container ul {        list-style-type: none;        padding-left: 1em;        line-height: 180%;        margin: 0;        overflow-wrap: break-word;  		word-wrap: break-word;      }      #toc > li > a {        font-weight: bold;        overflow-wrap: break-word;  		word-wrap: break-word;      }      /* File heading div */      .file-heading {        width: 100%;        display: table;        border-bottom: 1px solid #aaa;        margin: 4em 0 1.5em 0;      }      .file-heading h2 {        border: none;        display: table-cell;      }      .file-heading a {        text-align: right;        display: table-cell;      }      /* The 'M', 'E' and 'X' badges in the ToC */      .badge {        width: 1.6em;        height: 1.6em;        display: inline-block;        line-height: 1.6em;        text-align: center;        font-weight: bold;        font-size: 60%;        color: #d9534f;        background-color: #dff0c8;        margin: 0.5ex 1em 0.5ex -1em;        border: 1px solid #fbfbfb;        border-radius: 1ex;      }      .BigBadge {        height: 2.2em;        display: inline-block;        line-height: 2.2em;        text-align: center;        font-weight: bold;        font-size: 100%;        color: #d9534f;        background-color: #dff0c8;        margin: 0.5ex 1em 0.5ex 0em;        border: 1px solid #fbfbfb;        border-radius: 1ex;      }          </style>    <!-- User custom CSS -->    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>  </head>  <body><div id="content"><div id="left"><h2>Table of Contents</h2>
<p>
<div id="toc-container">
<ul id="toc">
<li>
<a href=#AccountBalanceFile.proto>AccountBalanceFile.proto</a>
<ul>
<li>
<a href="#AllAccountBalances"><span class="badge">M</span>AllAccountBalances</a></li>
<li>
<a href="#SingleAccountBalances"><span class="badge">M</span>SingleAccountBalances</a></li>
<li>
<a href="#TokenUnitBalance"><span class="badge">M</span>TokenUnitBalance</a></li>
</ul>
<a href=#BasicTypes.proto>BasicTypes.proto</a>
<ul>
<li>
<a href="#AccountAmount"><span class="badge">M</span>AccountAmount</a></li>
<li>
<a href="#AccountID"><span class="badge">M</span>AccountID</a></li>
<li>
<a href="#ContractID"><span class="badge">M</span>ContractID</a></li>
<li>
<a href="#CurrentAndNextFeeSchedule"><span class="badge">M</span>CurrentAndNextFeeSchedule</a></li>
<li>
<a href="#FeeComponents"><span class="badge">M</span>FeeComponents</a></li>
<li>
<a href="#FeeData"><span class="badge">M</span>FeeData</a></li>
<li>
<a href="#FeeSchedule"><span class="badge">M</span>FeeSchedule</a></li>
<li>
<a href="#FileID"><span class="badge">M</span>FileID</a></li>
<li>
<a href="#HederaFunctionality"><span class="badge">E</span>HederaFunctionality</a></li>
<li>
<a href="#Key"><span class="badge">M</span>Key</a></li>
<li>
<a href="#KeyList"><span class="badge">M</span>KeyList</a></li>
<li>
<a href="#NftTransfer"><span class="badge">M</span>NftTransfer</a></li>
<li>
<a href="#NodeAddress"><span class="badge">M</span>NodeAddress</a></li>
<li>
<a href="#NodeAddressBook"><span class="badge">M</span>NodeAddressBook</a></li>
<li>
<a href="#RealmID"><span class="badge">M</span>RealmID</a></li>
<li>
<a href="#ScheduleID"><span class="badge">M</span>ScheduleID</a></li>
<li>
<a href="#SemanticVersion"><span class="badge">M</span>SemanticVersion</a></li>
<li>
<a href="#ServiceEndpoint"><span class="badge">M</span>ServiceEndpoint</a></li>
<li>
<a href="#ServicesConfigurationList"><span class="badge">M</span>ServicesConfigurationList</a></li>
<li>
<a href="#Setting"><span class="badge">M</span>Setting</a></li>
<li>
<a href="#ShardID"><span class="badge">M</span>ShardID</a></li>
<li>
<a href="#Signature"><span class="badge">M</span>Signature</a></li>
<li>
<a href="#SignatureList"><span class="badge">M</span>SignatureList</a></li>
<li>
<a href="#SignatureMap"><span class="badge">M</span>SignatureMap</a></li>
<li>
<a href="#SignaturePair"><span class="badge">M</span>SignaturePair</a></li>
<li>
<a href="#SubType"><span class="badge">E</span>SubType</a></li>
<li>
<a href="#ThresholdKey"><span class="badge">M</span>ThresholdKey</a></li>
<li>
<a href="#ThresholdSignature"><span class="badge">M</span>ThresholdSignature</a></li>
<li>
<a href="#TokenBalance"><span class="badge">M</span>TokenBalance</a></li>
<li>
<a href="#TokenBalances"><span class="badge">M</span>TokenBalances</a></li>
<li>
<a href="#TokenFreezeStatus"><span class="badge">E</span>TokenFreezeStatus</a></li>
<li>
<a href="#TokenID"><span class="badge">M</span>TokenID</a></li>
<li>
<a href="#TokenKycStatus"><span class="badge">E</span>TokenKycStatus</a></li>
<li>
<a href="#TokenRelationship"><span class="badge">M</span>TokenRelationship</a></li>
<li>
<a href="#TokenSupplyType"><span class="badge">E</span>TokenSupplyType</a></li>
<li>
<a href="#TokenTransferList"><span class="badge">M</span>TokenTransferList</a></li>
<li>
<a href="#TokenType"><span class="badge">E</span>TokenType</a></li>
<li>
<a href="#TopicID"><span class="badge">M</span>TopicID</a></li>
<li>
<a href="#TransactionFeeSchedule"><span class="badge">M</span>TransactionFeeSchedule</a></li>
<li>
<a href="#TransactionID"><span class="badge">M</span>TransactionID</a></li>
<li>
<a href="#TransferList"><span class="badge">M</span>TransferList</a></li>
</ul>
<a href=#ConsensusCreateTopic.proto>ConsensusCreateTopic.proto</a>
<ul>
<li>
<a href="#ConsensusCreateTopicTransactionBody"><span class="badge">M</span>ConsensusCreateTopicTransactionBody</a></li>
</ul>
<a href=#ConsensusDeleteTopic.proto>ConsensusDeleteTopic.proto</a>
<ul>
<li>
<a href="#ConsensusDeleteTopicTransactionBody"><span class="badge">M</span>ConsensusDeleteTopicTransactionBody</a></li>
</ul>
<a href=#ConsensusGetTopicInfo.proto>ConsensusGetTopicInfo.proto</a>
<ul>
<li>
<a href="#ConsensusGetTopicInfoQuery"><span class="badge">M</span>ConsensusGetTopicInfoQuery</a></li>
<li>
<a href="#ConsensusGetTopicInfoResponse"><span class="badge">M</span>ConsensusGetTopicInfoResponse</a></li>
</ul>
<a href=#ConsensusService.proto>ConsensusService.proto</a>
<ul>
<li>
<a href="#ConsensusService"><span class="badge">S</span>ConsensusService</a></li>
</ul>
<a href=#ConsensusSubmitMessage.proto>ConsensusSubmitMessage.proto</a>
<ul>
<li>
<a href="#ConsensusMessageChunkInfo"><span class="badge">M</span>ConsensusMessageChunkInfo</a></li>
<li>
<a href="#ConsensusSubmitMessageTransactionBody"><span class="badge">M</span>ConsensusSubmitMessageTransactionBody</a></li>
</ul>
<a href=#ConsensusTopicInfo.proto>ConsensusTopicInfo.proto</a>
<ul>
<li>
<a href="#ConsensusTopicInfo"><span class="badge">M</span>ConsensusTopicInfo</a></li>
</ul>
<a href=#ConsensusUpdateTopic.proto>ConsensusUpdateTopic.proto</a>
<ul>
<li>
<a href="#ConsensusUpdateTopicTransactionBody"><span class="badge">M</span>ConsensusUpdateTopicTransactionBody</a></li>
</ul>
<a href=#ContractCall.proto>ContractCall.proto</a>
<ul>
<li>
<a href="#ContractCallTransactionBody"><span class="badge">M</span>ContractCallTransactionBody</a></li>
</ul>
<a href=#ContractCallLocal.proto>ContractCallLocal.proto</a>
<ul>
<li>
<a href="#ContractCallLocalQuery"><span class="badge">M</span>ContractCallLocalQuery</a></li>
<li>
<a href="#ContractCallLocalResponse"><span class="badge">M</span>ContractCallLocalResponse</a></li>
<li>
<a href="#ContractFunctionResult"><span class="badge">M</span>ContractFunctionResult</a></li>
<li>
<a href="#ContractLoginfo"><span class="badge">M</span>ContractLoginfo</a></li>
</ul>
<a href=#ContractCreate.proto>ContractCreate.proto</a>
<ul>
<li>
<a href="#ContractCreateTransactionBody"><span class="badge">M</span>ContractCreateTransactionBody</a></li>
</ul>
<a href=#ContractDelete.proto>ContractDelete.proto</a>
<ul>
<li>
<a href="#ContractDeleteTransactionBody"><span class="badge">M</span>ContractDeleteTransactionBody</a></li>
</ul>
<a href=#ContractGetBytecode.proto>ContractGetBytecode.proto</a>
<ul>
<li>
<a href="#ContractGetBytecodeQuery"><span class="badge">M</span>ContractGetBytecodeQuery</a></li>
<li>
<a href="#ContractGetBytecodeResponse"><span class="badge">M</span>ContractGetBytecodeResponse</a></li>
</ul>
<a href=#ContractGetInfo.proto>ContractGetInfo.proto</a>
<ul>
<li>
<a href="#ContractGetInfoQuery"><span class="badge">M</span>ContractGetInfoQuery</a></li>
<li>
<a href="#ContractGetInfoResponse"><span class="badge">M</span>ContractGetInfoResponse</a></li>
<li>
<a href="#ContractGetInfoResponse.ContractInfo"><span class="badge">M</span>ContractGetInfoResponse.ContractInfo</a></li>
</ul>
<a href=#ContractGetRecords.proto>ContractGetRecords.proto</a>
<ul>
<li>
<a href="#ContractGetRecordsQuery"><span class="badge">M</span>ContractGetRecordsQuery</a></li>
<li>
<a href="#ContractGetRecordsResponse"><span class="badge">M</span>ContractGetRecordsResponse</a></li>
</ul>
<a href=#ContractUpdate.proto>ContractUpdate.proto</a>
<ul>
<li>
<a href="#ContractUpdateTransactionBody"><span class="badge">M</span>ContractUpdateTransactionBody</a></li>
</ul>
<a href=#CryptoAddLiveHash.proto>CryptoAddLiveHash.proto</a>
<ul>
<li>
<a href="#CryptoAddLiveHashTransactionBody"><span class="badge">M</span>CryptoAddLiveHashTransactionBody</a></li>
<li>
<a href="#LiveHash"><span class="badge">M</span>LiveHash</a></li>
</ul>
<a href=#CryptoCreate.proto>CryptoCreate.proto</a>
<ul>
<li>
<a href="#CryptoCreateTransactionBody"><span class="badge">M</span>CryptoCreateTransactionBody</a></li>
</ul>
<a href=#CryptoDelete.proto>CryptoDelete.proto</a>
<ul>
<li>
<a href="#CryptoDeleteTransactionBody"><span class="badge">M</span>CryptoDeleteTransactionBody</a></li>
</ul>
<a href=#CryptoDeleteLiveHash.proto>CryptoDeleteLiveHash.proto</a>
<ul>
<li>
<a href="#CryptoDeleteLiveHashTransactionBody"><span class="badge">M</span>CryptoDeleteLiveHashTransactionBody</a></li>
</ul>
<a href=#CryptoGetAccountBalance.proto>CryptoGetAccountBalance.proto</a>
<ul>
<li>
<a href="#CryptoGetAccountBalanceQuery"><span class="badge">M</span>CryptoGetAccountBalanceQuery</a></li>
<li>
<a href="#CryptoGetAccountBalanceResponse"><span class="badge">M</span>CryptoGetAccountBalanceResponse</a></li>
</ul>
<a href=#CryptoGetAccountRecords.proto>CryptoGetAccountRecords.proto</a>
<ul>
<li>
<a href="#CryptoGetAccountRecordsQuery"><span class="badge">M</span>CryptoGetAccountRecordsQuery</a></li>
<li>
<a href="#CryptoGetAccountRecordsResponse"><span class="badge">M</span>CryptoGetAccountRecordsResponse</a></li>
</ul>
<a href=#CryptoGetInfo.proto>CryptoGetInfo.proto</a>
<ul>
<li>
<a href="#CryptoGetInfoQuery"><span class="badge">M</span>CryptoGetInfoQuery</a></li>
<li>
<a href="#CryptoGetInfoResponse"><span class="badge">M</span>CryptoGetInfoResponse</a></li>
<li>
<a href="#CryptoGetInfoResponse.AccountInfo"><span class="badge">M</span>CryptoGetInfoResponse.AccountInfo</a></li>
</ul>
<a href=#CryptoGetLiveHash.proto>CryptoGetLiveHash.proto</a>
<ul>
<li>
<a href="#CryptoGetLiveHashQuery"><span class="badge">M</span>CryptoGetLiveHashQuery</a></li>
<li>
<a href="#CryptoGetLiveHashResponse"><span class="badge">M</span>CryptoGetLiveHashResponse</a></li>
</ul>
<a href=#CryptoGetStakers.proto>CryptoGetStakers.proto</a>
<ul>
<li>
<a href="#AllProxyStakers"><span class="badge">M</span>AllProxyStakers</a></li>
<li>
<a href="#CryptoGetStakersQuery"><span class="badge">M</span>CryptoGetStakersQuery</a></li>
<li>
<a href="#CryptoGetStakersResponse"><span class="badge">M</span>CryptoGetStakersResponse</a></li>
<li>
<a href="#ProxyStaker"><span class="badge">M</span>ProxyStaker</a></li>
</ul>
<a href=#CryptoService.proto>CryptoService.proto</a>
<ul>
<li>
<a href="#CryptoService"><span class="badge">S</span>CryptoService</a></li>
</ul>
<a href=#CryptoTransfer.proto>CryptoTransfer.proto</a>
<ul>
<li>
<a href="#CryptoTransferTransactionBody"><span class="badge">M</span>CryptoTransferTransactionBody</a></li>
</ul>
<a href=#CryptoUpdate.proto>CryptoUpdate.proto</a>
<ul>
<li>
<a href="#CryptoUpdateTransactionBody"><span class="badge">M</span>CryptoUpdateTransactionBody</a></li>
</ul>
<a href=#Duration.proto>Duration.proto</a>
<ul>
<li>
<a href="#Duration"><span class="badge">M</span>Duration</a></li>
</ul>
<a href=#ExchangeRate.proto>ExchangeRate.proto</a>
<ul>
<li>
<a href="#ExchangeRate"><span class="badge">M</span>ExchangeRate</a></li>
<li>
<a href="#ExchangeRateSet"><span class="badge">M</span>ExchangeRateSet</a></li>
</ul>
<a href=#FileAppend.proto>FileAppend.proto</a>
<ul>
<li>
<a href="#FileAppendTransactionBody"><span class="badge">M</span>FileAppendTransactionBody</a></li>
</ul>
<a href=#FileCreate.proto>FileCreate.proto</a>
<ul>
<li>
<a href="#FileCreateTransactionBody"><span class="badge">M</span>FileCreateTransactionBody</a></li>
</ul>
<a href=#FileDelete.proto>FileDelete.proto</a>
<ul>
<li>
<a href="#FileDeleteTransactionBody"><span class="badge">M</span>FileDeleteTransactionBody</a></li>
</ul>
<a href=#FileGetContents.proto>FileGetContents.proto</a>
<ul>
<li>
<a href="#FileGetContentsQuery"><span class="badge">M</span>FileGetContentsQuery</a></li>
<li>
<a href="#FileGetContentsResponse"><span class="badge">M</span>FileGetContentsResponse</a></li>
<li>
<a href="#FileGetContentsResponse.FileContents"><span class="badge">M</span>FileGetContentsResponse.FileContents</a></li>
</ul>
<a href=#FileGetInfo.proto>FileGetInfo.proto</a>
<ul>
<li>
<a href="#FileGetInfoQuery"><span class="badge">M</span>FileGetInfoQuery</a></li>
<li>
<a href="#FileGetInfoResponse"><span class="badge">M</span>FileGetInfoResponse</a></li>
<li>
<a href="#FileGetInfoResponse.FileInfo"><span class="badge">M</span>FileGetInfoResponse.FileInfo</a></li>
</ul>
<a href=#FileService.proto>FileService.proto</a>
<ul>
<li>
<a href="#FileService"><span class="badge">S</span>FileService</a></li>
</ul>
<a href=#FileUpdate.proto>FileUpdate.proto</a>
<ul>
<li>
<a href="#FileUpdateTransactionBody"><span class="badge">M</span>FileUpdateTransactionBody</a></li>
</ul>
<a href=#Freeze.proto>Freeze.proto</a>
<ul>
<li>
<a href="#FreezeTransactionBody"><span class="badge">M</span>FreezeTransactionBody</a></li>
</ul>
<a href=#FreezeService.proto>FreezeService.proto</a>
<ul>
<li>
<a href="#FreezeService"><span class="badge">S</span>FreezeService</a></li>
</ul>
<a href=#GetByKey.proto>GetByKey.proto</a>
<ul>
<li>
<a href="#EntityID"><span class="badge">M</span>EntityID</a></li>
<li>
<a href="#GetByKeyQuery"><span class="badge">M</span>GetByKeyQuery</a></li>
<li>
<a href="#GetByKeyResponse"><span class="badge">M</span>GetByKeyResponse</a></li>
</ul>
<a href=#GetBySolidityID.proto>GetBySolidityID.proto</a>
<ul>
<li>
<a href="#GetBySolidityIDQuery"><span class="badge">M</span>GetBySolidityIDQuery</a></li>
<li>
<a href="#GetBySolidityIDResponse"><span class="badge">M</span>GetBySolidityIDResponse</a></li>
</ul>
<a href=#NetworkGetVersionInfo.proto>NetworkGetVersionInfo.proto</a>
<ul>
<li>
<a href="#NetworkGetVersionInfoQuery"><span class="badge">M</span>NetworkGetVersionInfoQuery</a></li>
<li>
<a href="#NetworkGetVersionInfoResponse"><span class="badge">M</span>NetworkGetVersionInfoResponse</a></li>
</ul>
<a href=#NetworkService.proto>NetworkService.proto</a>
<ul>
<li>
<a href="#NetworkService"><span class="badge">S</span>NetworkService</a></li>
</ul>
<a href=#Query.proto>Query.proto</a>
<ul>
<li>
<a href="#Query"><span class="badge">M</span>Query</a></li>
</ul>
<a href=#QueryHeader.proto>QueryHeader.proto</a>
<ul>
<li>
<a href="#QueryHeader"><span class="badge">M</span>QueryHeader</a></li>
<li>
<a href="#ResponseType"><span class="badge">E</span>ResponseType</a></li>
</ul>
<a href=#Response.proto>Response.proto</a>
<ul>
<li>
<a href="#Response"><span class="badge">M</span>Response</a></li>
</ul>
<a href=#ResponseCode.proto>ResponseCode.proto</a>
<ul>
<li>
<a href="#ResponseCodeEnum"><span class="badge">E</span>ResponseCodeEnum</a></li>
</ul>
<a href=#ResponseHeader.proto>ResponseHeader.proto</a>
<ul>
<li>
<a href="#ResponseHeader"><span class="badge">M</span>ResponseHeader</a></li>
</ul>
<a href=#SchedulableTransactionBody.proto>SchedulableTransactionBody.proto</a>
<ul>
<li>
<a href="#SchedulableTransactionBody"><span class="badge">M</span>SchedulableTransactionBody</a></li>
</ul>
<a href=#ScheduleCreate.proto>ScheduleCreate.proto</a>
<ul>
<li>
<a href="#ScheduleCreateTransactionBody"><span class="badge">M</span>ScheduleCreateTransactionBody</a></li>
</ul>
<a href=#ScheduleDelete.proto>ScheduleDelete.proto</a>
<ul>
<li>
<a href="#ScheduleDeleteTransactionBody"><span class="badge">M</span>ScheduleDeleteTransactionBody</a></li>
</ul>
<a href=#ScheduleGetInfo.proto>ScheduleGetInfo.proto</a>
<ul>
<li>
<a href="#ScheduleGetInfoQuery"><span class="badge">M</span>ScheduleGetInfoQuery</a></li>
<li>
<a href="#ScheduleGetInfoResponse"><span class="badge">M</span>ScheduleGetInfoResponse</a></li>
<li>
<a href="#ScheduleInfo"><span class="badge">M</span>ScheduleInfo</a></li>
</ul>
<a href=#ScheduleService.proto>ScheduleService.proto</a>
<ul>
<li>
<a href="#ScheduleService"><span class="badge">S</span>ScheduleService</a></li>
</ul>
<a href=#ScheduleSign.proto>ScheduleSign.proto</a>
<ul>
<li>
<a href="#ScheduleSignTransactionBody"><span class="badge">M</span>ScheduleSignTransactionBody</a></li>
</ul>
<a href=#SmartContractService.proto>SmartContractService.proto</a>
<ul>
<li>
<a href="#SmartContractService"><span class="badge">S</span>SmartContractService</a></li>
</ul>
<a href=#SystemDelete.proto>SystemDelete.proto</a>
<ul>
<li>
<a href="#SystemDeleteTransactionBody"><span class="badge">M</span>SystemDeleteTransactionBody</a></li>
</ul>
<a href=#SystemUndelete.proto>SystemUndelete.proto</a>
<ul>
<li>
<a href="#SystemUndeleteTransactionBody"><span class="badge">M</span>SystemUndeleteTransactionBody</a></li>
</ul>
<a href=#ThrottleDefinitions.proto>ThrottleDefinitions.proto</a>
<ul>
<li>
<a href="#ThrottleBucket"><span class="badge">M</span>ThrottleBucket</a></li>
<li>
<a href="#ThrottleDefinitions"><span class="badge">M</span>ThrottleDefinitions</a></li>
<li>
<a href="#ThrottleGroup"><span class="badge">M</span>ThrottleGroup</a></li>
</ul>
<a href=#Timestamp.proto>Timestamp.proto</a>
<ul>
<li>
<a href="#Timestamp"><span class="badge">M</span>Timestamp</a></li>
<li>
<a href="#TimestampSeconds"><span class="badge">M</span>TimestampSeconds</a></li>
</ul>
<a href=#TokenAssociate.proto>TokenAssociate.proto</a>
<ul>
<li>
<a href="#TokenAssociateTransactionBody"><span class="badge">M</span>TokenAssociateTransactionBody</a></li>
</ul>
<a href=#TokenBurn.proto>TokenBurn.proto</a>
<ul>
<li>
<a href="#TokenBurnTransactionBody"><span class="badge">M</span>TokenBurnTransactionBody</a></li>
</ul>
<a href=#TokenCreate.proto>TokenCreate.proto</a>
<ul>
<li>
<a href="#TokenCreateTransactionBody"><span class="badge">M</span>TokenCreateTransactionBody</a></li>
</ul>
<a href=#TokenDelete.proto>TokenDelete.proto</a>
<ul>
<li>
<a href="#TokenDeleteTransactionBody"><span class="badge">M</span>TokenDeleteTransactionBody</a></li>
</ul>
<a href=#TokenDissociate.proto>TokenDissociate.proto</a>
<ul>
<li>
<a href="#TokenDissociateTransactionBody"><span class="badge">M</span>TokenDissociateTransactionBody</a></li>
</ul>
<a href=#TokenFreezeAccount.proto>TokenFreezeAccount.proto</a>
<ul>
<li>
<a href="#TokenFreezeAccountTransactionBody"><span class="badge">M</span>TokenFreezeAccountTransactionBody</a></li>
</ul>
<a href=#TokenGetAccountNftInfo.proto>TokenGetAccountNftInfo.proto</a>
<ul>
<li>
<a href="#TokenGetAccountNftInfoQuery"><span class="badge">M</span>TokenGetAccountNftInfoQuery</a></li>
<li>
<a href="#TokenGetAccountNftInfoResponse"><span class="badge">M</span>TokenGetAccountNftInfoResponse</a></li>
</ul>
<a href=#TokenGetInfo.proto>TokenGetInfo.proto</a>
<ul>
<li>
<a href="#TokenGetInfoQuery"><span class="badge">M</span>TokenGetInfoQuery</a></li>
<li>
<a href="#TokenGetInfoResponse"><span class="badge">M</span>TokenGetInfoResponse</a></li>
<li>
<a href="#TokenInfo"><span class="badge">M</span>TokenInfo</a></li>
</ul>
<a href=#TokenGetNftInfo.proto>TokenGetNftInfo.proto</a>
<ul>
<li>
<a href="#NftID"><span class="badge">M</span>NftID</a></li>
<li>
<a href="#TokenGetNftInfoQuery"><span class="badge">M</span>TokenGetNftInfoQuery</a></li>
<li>
<a href="#TokenGetNftInfoResponse"><span class="badge">M</span>TokenGetNftInfoResponse</a></li>
<li>
<a href="#TokenNftInfo"><span class="badge">M</span>TokenNftInfo</a></li>
</ul>
<a href=#TokenGetNftInfos.proto>TokenGetNftInfos.proto</a>
<ul>
<li>
<a href="#TokenGetNftInfosQuery"><span class="badge">M</span>TokenGetNftInfosQuery</a></li>
<li>
<a href="#TokenGetNftInfosResponse"><span class="badge">M</span>TokenGetNftInfosResponse</a></li>
</ul>
<a href=#TokenGrantKyc.proto>TokenGrantKyc.proto</a>
<ul>
<li>
<a href="#TokenGrantKycTransactionBody"><span class="badge">M</span>TokenGrantKycTransactionBody</a></li>
</ul>
<a href=#TokenMint.proto>TokenMint.proto</a>
<ul>
<li>
<a href="#TokenMintTransactionBody"><span class="badge">M</span>TokenMintTransactionBody</a></li>
</ul>
<a href=#TokenRevokeKyc.proto>TokenRevokeKyc.proto</a>
<ul>
<li>
<a href="#TokenRevokeKycTransactionBody"><span class="badge">M</span>TokenRevokeKycTransactionBody</a></li>
</ul>
<a href=#TokenService.proto>TokenService.proto</a>
<ul>
<li>
<a href="#TokenService"><span class="badge">S</span>TokenService</a></li>
</ul>
<a href=#TokenUnfreezeAccount.proto>TokenUnfreezeAccount.proto</a>
<ul>
<li>
<a href="#TokenUnfreezeAccountTransactionBody"><span class="badge">M</span>TokenUnfreezeAccountTransactionBody</a></li>
</ul>
<a href=#TokenUpdate.proto>TokenUpdate.proto</a>
<ul>
<li>
<a href="#TokenUpdateTransactionBody"><span class="badge">M</span>TokenUpdateTransactionBody</a></li>
</ul>
<a href=#TokenWipeAccount.proto>TokenWipeAccount.proto</a>
<ul>
<li>
<a href="#TokenWipeAccountTransactionBody"><span class="badge">M</span>TokenWipeAccountTransactionBody</a></li>
</ul>
<a href=#Transaction.proto>Transaction.proto</a>
<ul>
<li>
<a href="#Transaction"><span class="badge">M</span>Transaction</a></li>
</ul>
<a href=#TransactionBody.proto>TransactionBody.proto</a>
<ul>
<li>
<a href="#TransactionBody"><span class="badge">M</span>TransactionBody</a></li>
</ul>
<a href=#TransactionContents.proto>TransactionContents.proto</a>
<ul>
<li>
<a href="#SignedTransaction"><span class="badge">M</span>SignedTransaction</a></li>
</ul>
<a href=#TransactionGetFastRecord.proto>TransactionGetFastRecord.proto</a>
<ul>
<li>
<a href="#TransactionGetFastRecordQuery"><span class="badge">M</span>TransactionGetFastRecordQuery</a></li>
<li>
<a href="#TransactionGetFastRecordResponse"><span class="badge">M</span>TransactionGetFastRecordResponse</a></li>
</ul>
<a href=#TransactionGetReceipt.proto>TransactionGetReceipt.proto</a>
<ul>
<li>
<a href="#TransactionGetReceiptQuery"><span class="badge">M</span>TransactionGetReceiptQuery</a></li>
<li>
<a href="#TransactionGetReceiptResponse"><span class="badge">M</span>TransactionGetReceiptResponse</a></li>
</ul>
<a href=#TransactionGetRecord.proto>TransactionGetRecord.proto</a>
<ul>
<li>
<a href="#TransactionGetRecordQuery"><span class="badge">M</span>TransactionGetRecordQuery</a></li>
<li>
<a href="#TransactionGetRecordResponse"><span class="badge">M</span>TransactionGetRecordResponse</a></li>
</ul>
<a href=#TransactionReceipt.proto>TransactionReceipt.proto</a>
<ul>
<li>
<a href="#TransactionReceipt"><span class="badge">M</span>TransactionReceipt</a></li>
</ul>
<a href=#TransactionRecord.proto>TransactionRecord.proto</a>
<ul>
<li>
<a href="#TransactionRecord"><span class="badge">M</span>TransactionRecord</a></li>
</ul>
<a href=#TransactionResponse.proto>TransactionResponse.proto</a>
<ul>
<li>
<a href="#TransactionResponse"><span class="badge">M</span>TransactionResponse</a></li>
</ul>
<a href=#UncheckedSubmit.proto>UncheckedSubmit.proto</a>
<ul>
<li>
<a href="#UncheckedSubmitBody"><span class="badge">M</span>UncheckedSubmitBody</a></li>
</ul>
</li>
</ul>
</div>
</p>
</div><div id="right"><h1 id="title">HAPI Documentation</h1>
<div class="file-heading">
<H2 id="AccountBalanceFile.proto">AccountBalanceFile.proto</H2>
<a href="#title">Top</a>
</div>
<P>-<BR>‌<BR>Hedera Network Services Protobuf<BR>​<BR>Copyright (C) 2018 - 2021 Hedera Hashgraph, LLC<BR>​<BR>Licensed under the Apache License, Version 2.0 (the "License");<BR>you may not use this file except in compliance with the License.<BR>You may obtain a copy of the License at<BR>http:www.apache.org/licenses/LICENSE-2.0<BR>Unless required by applicable law or agreed to in writing, software<BR>distributed under the License is distributed on an "AS IS" BASIS,<BR>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<BR>See the License for the specific language governing permissions and<BR>limitations under the License.<BR>‍</P>
<H3 id="AllAccountBalances"><span class="BigBadge">Message</span>AllAccountBalances</H3>
<P> Includes all currency balances (both hbar and token) of all accounts in the ledger. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>An instant in consensus time</P></TD>
</TR>

<TR>
<TD>allAccounts</TD>
<TD><a href="#SingleAccountBalances">SingleAccountBalances</a> (repeated)</TD>
<TD><P>The list of account balances for all accounts, after handling all transactions with consensus timestamp up to and including the above instant</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="SingleAccountBalances"><span class="BigBadge">Message</span>SingleAccountBalances</H3>
<P> Includes all currency balances (both hbar and token) of a single account in the ledger. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account</P></TD>
</TR>

<TR>
<TD>hbarBalance</TD>
<TD>uint64</TD>
<TD><P>The account's hbar balance</P></TD>
</TR>

<TR>
<TD>tokenUnitBalances</TD>
<TD><a href="#TokenUnitBalance">TokenUnitBalance</a> (repeated)</TD>
<TD><P>The list of the account's token balances</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenUnitBalance"><span class="BigBadge">Message</span>TokenUnitBalance</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>tokenId</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>A unique token id</P></TD>
</TR>

<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD><P>Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON - balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="BasicTypes.proto">BasicTypes.proto</H2>
<a href="#title">Top</a>
</div>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<H3 id="AccountAmount"><span class="BigBadge">Message</span>AccountAmount</H3>
<P> An account, and the amount that it sends or receives during a cryptocurrency or token transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID that sends/receives cryptocurrency or tokens</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD><P>The amount of tinybars (for Crypto transfers) or in the lowest denomination (for Token transfers) that the account sends(negative) or receives(positive)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="AccountID"><span class="BigBadge">Message</span>AccountID</H3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>The shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD><P>The realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative account number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractID"><span class="BigBadge">Message</span>ContractID</H3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>The shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD><P>The realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CurrentAndNextFeeSchedule"><span class="BigBadge">Message</span>CurrentAndNextFeeSchedule</H3>
<P> This contains two Fee Schedules with expiry timestamp. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>currentFeeSchedule</TD>
<TD><a href="#FeeSchedule">FeeSchedule</a></TD>
<TD><P>Contains current Fee Schedule</P></TD>
</TR>

<TR>
<TD>nextFeeSchedule</TD>
<TD><a href="#FeeSchedule">FeeSchedule</a></TD>
<TD><P>Contains next Fee Schedule</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FeeComponents"><span class="BigBadge">Message</span>FeeComponents</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD><P>A minimum, the calculated fee must be greater than this value</P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD><P>A maximum, the calculated fee must be less than this value</P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD><P>A constant contribution to the fee</P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD><P>The price of bandwidth consumed by a transaction, measured in bytes</P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD><P>The price per signature verification for a transaction</P></TD>
</TR>

<TR>
<TD>rbh</TD>
<TD>int64</TD>
<TD><P>The price of RAM consumed by a transaction, measured in byte-hours</P></TD>
</TR>

<TR>
<TD>sbh</TD>
<TD>int64</TD>
<TD><P>The price of storage consumed by a transaction, measured in byte-hours</P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD><P>The price of computation for a smart contract transaction, measured in gas</P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD><P>The price per hbar transferred for a transfer</P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD><P>The price of bandwidth for data retrieved from memory for a response, measured in bytes</P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD><P>The price of bandwidth for data retrieved from disk for a response, measured in bytes</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FeeData"><span class="BigBadge">Message</span>FeeData</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD><P> Fee paid to the submitting node</P></TD>
</TR>

<TR>
<TD>networkdata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD><P> Fee paid to the network for processing a transaction into consensus</P></TD>
</TR>

<TR>
<TD>servicedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD><P> Fee paid to the network for providing the service associated with the transaction; for instance, storing a file</P></TD>
</TR>

<TR>
<TD>subType</TD>
<TD><a href="#SubType">SubType</a></TD>
<TD><P> SubType distinguishing between different types of FeeData, correlating to the same HederaFunctionality</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FeeSchedule"><span class="BigBadge">Message</span>FeeSchedule</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionFeeSchedule</TD>
<TD><a href="#TransactionFeeSchedule">TransactionFeeSchedule</a> (repeated)</TD>
<TD><P> List of price coefficients for network resources</P></TD>
</TR>

<TR>
<TD>expiryTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD><P> FeeSchedule expiry time</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FileID"><span class="BigBadge">Message</span>FileID</H3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>The shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD><P>The realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative File number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="HederaFunctionality"><span class="BigBadge">Enum</span>HederaFunctionality</H3>
<P></P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>NONE</TD>
<TD><P>UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and not parsed (0 is ignored by parser)</P></TD>
</TR>

<TR>
<TD>CryptoTransfer</TD>
<TD><P>crypto transfer</P></TD>
</TR>

<TR>
<TD>CryptoUpdate</TD>
<TD><P>crypto update account</P></TD>
</TR>

<TR>
<TD>CryptoDelete</TD>
<TD><P>crypto delete account</P></TD>
</TR>

<TR>
<TD>CryptoAddLiveHash</TD>
<TD><P> Add a livehash to a crypto account</P></TD>
</TR>

<TR>
<TD>CryptoDeleteLiveHash</TD>
<TD><P> Delete a livehash from a crypto account</P></TD>
</TR>

<TR>
<TD>ContractCall</TD>
<TD><P>Smart Contract Call</P></TD>
</TR>

<TR>
<TD>ContractCreate</TD>
<TD><P>Smart Contract Create Contract</P></TD>
</TR>

<TR>
<TD>ContractUpdate</TD>
<TD><P>Smart Contract update contract</P></TD>
</TR>

<TR>
<TD>FileCreate</TD>
<TD><P>File Operation create file</P></TD>
</TR>

<TR>
<TD>FileAppend</TD>
<TD><P>File Operation append file</P></TD>
</TR>

<TR>
<TD>FileUpdate</TD>
<TD><P>File Operation update file</P></TD>
</TR>

<TR>
<TD>FileDelete</TD>
<TD><P>File Operation delete file</P></TD>
</TR>

<TR>
<TD>CryptoGetAccountBalance</TD>
<TD><P>crypto get account balance</P></TD>
</TR>

<TR>
<TD>CryptoGetAccountRecords</TD>
<TD><P>crypto get account record</P></TD>
</TR>

<TR>
<TD>CryptoGetInfo</TD>
<TD><P>Crypto get info</P></TD>
</TR>

<TR>
<TD>ContractCallLocal</TD>
<TD><P>Smart Contract Call</P></TD>
</TR>

<TR>
<TD>ContractGetInfo</TD>
<TD><P>Smart Contract get info</P></TD>
</TR>

<TR>
<TD>ContractGetBytecode</TD>
<TD><P>Smart Contract, get the byte code</P></TD>
</TR>

<TR>
<TD>GetBySolidityID</TD>
<TD><P>Smart Contract, get by solidity ID</P></TD>
</TR>

<TR>
<TD>GetByKey</TD>
<TD><P>Smart Contract, get by key</P></TD>
</TR>

<TR>
<TD>CryptoGetLiveHash</TD>
<TD><P> Get a live hash from a crypto account</P></TD>
</TR>

<TR>
<TD>CryptoGetStakers</TD>
<TD><P>Crypto, get the stakers for the node</P></TD>
</TR>

<TR>
<TD>FileGetContents</TD>
<TD><P>File Operations get file contents</P></TD>
</TR>

<TR>
<TD>FileGetInfo</TD>
<TD><P>File Operations get the info of the file</P></TD>
</TR>

<TR>
<TD>TransactionGetRecord</TD>
<TD><P>Crypto get the transaction records</P></TD>
</TR>

<TR>
<TD>ContractGetRecords</TD>
<TD><P>Contract get the transaction records</P></TD>
</TR>

<TR>
<TD>CryptoCreate</TD>
<TD><P>crypto create account</P></TD>
</TR>

<TR>
<TD>SystemDelete</TD>
<TD><P>system delete file</P></TD>
</TR>

<TR>
<TD>SystemUndelete</TD>
<TD><P>system undelete file</P></TD>
</TR>

<TR>
<TD>ContractDelete</TD>
<TD><P>delete contract</P></TD>
</TR>

<TR>
<TD>Freeze</TD>
<TD><P>freeze</P></TD>
</TR>

<TR>
<TD>CreateTransactionRecord</TD>
<TD><P>Create Tx Record</P></TD>
</TR>

<TR>
<TD>CryptoAccountAutoRenew</TD>
<TD><P>Crypto Auto Renew</P></TD>
</TR>

<TR>
<TD>ContractAutoRenew</TD>
<TD><P>Contract Auto Renew</P></TD>
</TR>

<TR>
<TD>GetVersionInfo</TD>
<TD><P>Get Version</P></TD>
</TR>

<TR>
<TD>TransactionGetReceipt</TD>
<TD><P>Transaction Get Receipt</P></TD>
</TR>

<TR>
<TD>ConsensusCreateTopic</TD>
<TD><P>Create Topic</P></TD>
</TR>

<TR>
<TD>ConsensusUpdateTopic</TD>
<TD><P>Update Topic</P></TD>
</TR>

<TR>
<TD>ConsensusDeleteTopic</TD>
<TD><P>Delete Topic</P></TD>
</TR>

<TR>
<TD>ConsensusGetTopicInfo</TD>
<TD><P>Get Topic information</P></TD>
</TR>

<TR>
<TD>ConsensusSubmitMessage</TD>
<TD><P>Submit message to topic</P></TD>
</TR>

<TR>
<TD>UncheckedSubmit</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>TokenCreate</TD>
<TD><P>Create Token</P></TD>
</TR>

<TR>
<TD>TokenGetInfo</TD>
<TD><P>Get Token information</P></TD>
</TR>

<TR>
<TD>TokenFreezeAccount</TD>
<TD><P>Freeze Account</P></TD>
</TR>

<TR>
<TD>TokenUnfreezeAccount</TD>
<TD><P>Unfreeze Account</P></TD>
</TR>

<TR>
<TD>TokenGrantKycToAccount</TD>
<TD><P>Grant KYC to Account</P></TD>
</TR>

<TR>
<TD>TokenRevokeKycFromAccount</TD>
<TD><P>Revoke KYC from Account</P></TD>
</TR>

<TR>
<TD>TokenDelete</TD>
<TD><P>Delete Token</P></TD>
</TR>

<TR>
<TD>TokenUpdate</TD>
<TD><P>Update Token</P></TD>
</TR>

<TR>
<TD>TokenMint</TD>
<TD><P>Mint tokens to treasury</P></TD>
</TR>

<TR>
<TD>TokenBurn</TD>
<TD><P>Burn tokens from treasury</P></TD>
</TR>

<TR>
<TD>TokenAccountWipe</TD>
<TD><P>Wipe token amount from Account holder</P></TD>
</TR>

<TR>
<TD>TokenAssociateToAccount</TD>
<TD><P>Associate tokens to an account</P></TD>
</TR>

<TR>
<TD>TokenDissociateFromAccount</TD>
<TD><P>Dissociate tokens from an account</P></TD>
</TR>

<TR>
<TD>ScheduleCreate</TD>
<TD><P>Create Scheduled Transaction</P></TD>
</TR>

<TR>
<TD>ScheduleDelete</TD>
<TD><P>Delete Scheduled Transaction</P></TD>
</TR>

<TR>
<TD>ScheduleSign</TD>
<TD><P>Sign Scheduled Transaction</P></TD>
</TR>

<TR>
<TD>ScheduleGetInfo</TD>
<TD><P>Get Scheduled Transaction Information</P></TD>
</TR>

<TR>
<TD>TokenGetAccountNftInfo</TD>
<TD><P>Get Token Account Nft Information</P></TD>
</TR>

<TR>
<TD>TokenGetNftInfo</TD>
<TD><P>Get Token Nft Information</P></TD>
</TR>

<TR>
<TD>TokenGetNftInfos</TD>
<TD><P>Get Token Nft List Information</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="Key"><span class="BigBadge">Message</span>Key</H3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.<BR>A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.<BR>A key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.<BR>A Key can be a list of keys. Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key.<BR>A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive keys (e.g., ed25519) has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive keys (e.g., ed25519) has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.<BR>Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys. Only ed25519 primitive keys are currently supported.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD><P>ed25519 public key bytes</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD><P>RSA-3072 public key bytes</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD><P>ECDSA with the p-384 curve public key bytes</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD><P>A list of Keys of the Key type.</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="KeyList"><span class="BigBadge">Message</span>KeyList</H3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a> (repeated)</TD>
<TD><P>list of keys</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="NftTransfer"><span class="BigBadge">Message</span>NftTransfer</H3>
<P> A sender account, a receiver account, and the serial number of an NFT of a Token with NON_FUNGIBLE_UNIQUE type. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>senderAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The accountID of the sender</P></TD>
</TR>

<TR>
<TD>receiverAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The accountID of the receiver</P></TD>
</TR>

<TR>
<TD>serialNumber</TD>
<TD>int64</TD>
<TD><P>The serial number of the NFT</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="NodeAddress"><span class="BigBadge">Message</span>NodeAddress</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ipAddress</TD>
<TD>bytes</TD>
<TD><P>The IP address of the Node with separator & octets encoded in UTF-8. Usage is deprecated, ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports</P></TD>
</TR>

<TR>
<TD>portno</TD>
<TD>int32</TD>
<TD><P>The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>bytes</TD>
<TD><P>Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID</P></TD>
</TR>

<TR>
<TD>RSA_PubKey</TD>
<TD>string</TD>
<TD><P>The node's hex-encoded X509 RSA public key</P></TD>
</TR>

<TR>
<TD>nodeId</TD>
<TD>int64</TD>
<TD><P># A non-sequential identifier for the node</P></TD>
</TR>

<TR>
<TD>nodeAccountId</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P># The account to be paid for queries and transactions sent to this node</P></TD>
</TR>

<TR>
<TD>nodeCertHash</TD>
<TD>bytes</TD>
<TD><P># The hex-encoded SHA-384 hash of the X509 cert used to encrypt gRPC traffic to the node</P></TD>
</TR>

<TR>
<TD>serviceEndpoint</TD>
<TD><a href="#ServiceEndpoint">ServiceEndpoint</a> (repeated)</TD>
<TD><P># A node's service IP addresses and ports</P></TD>
</TR>

<TR>
<TD>description</TD>
<TD>string</TD>
<TD><P>A description of the node, with UTF-8 encoding up to 100 bytes</P></TD>
</TR>

<TR>
<TD>stake</TD>
<TD>int64</TD>
<TD><P>The amount of tinybars staked to the node</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="NodeAddressBook"><span class="BigBadge">Message</span>NodeAddressBook</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeAddress</TD>
<TD><a href="#NodeAddress">NodeAddress</a> (repeated)</TD>
<TD><P>Metadata of all nodes in the network</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="RealmID"><span class="BigBadge">Message</span>RealmID</H3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>The shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD><P>The realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ScheduleID"><span class="BigBadge">Message</span>ScheduleID</H3>
<P> Unique identifier for a Schedule </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative shard number</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative realm number</P></TD>
</TR>

<TR>
<TD>scheduleNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative schedule number</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="SemanticVersion"><span class="BigBadge">Message</span>SemanticVersion</H3>
<P> Hedera follows semantic versioning (https:semver.org/) for both the HAPI protobufs and the Services software.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>major</TD>
<TD>int32</TD>
<TD><P>Increases with incompatible API changes</P></TD>
</TR>

<TR>
<TD>minor</TD>
<TD>int32</TD>
<TD><P>Increases with backwards-compatible new functionality</P></TD>
</TR>

<TR>
<TD>patch</TD>
<TD>int32</TD>
<TD><P>Increases with backwards-compatible bug fixes</P></TD>
</TR>

<TR>
<TD>pre</TD>
<TD>string</TD>
<TD><P>A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers (https:semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3, this field would contain 'alpha.1'</P></TD>
</TR>

<TR>
<TD>build</TD>
<TD>string</TD>
<TD><P>Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version (https:semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field would contain '21AF26D3'</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ServiceEndpoint"><span class="BigBadge">Message</span>ServiceEndpoint</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ipAddressV4</TD>
<TD>bytes</TD>
<TD><P>The 32-bit IPv4 address of the node encoded in left to right order (e.g. 127.0.0.1 has 127 as its first byte)</P></TD>
</TR>

<TR>
<TD>port</TD>
<TD>int32</TD>
<TD><P>The port of the node</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ServicesConfigurationList"><span class="BigBadge">Message</span>ServicesConfigurationList</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nameValue</TD>
<TD><a href="#Setting">Setting</a> (repeated)</TD>
<TD><P>list of name value pairs of the application properties</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="Setting"><span class="BigBadge">Message</span>Setting</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>name</TD>
<TD>string</TD>
<TD><P>name of the property</P></TD>
</TR>

<TR>
<TD>value</TD>
<TD>string</TD>
<TD><P>value of the property</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD><P>any data associated with property</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ShardID"><span class="BigBadge">Message</span>ShardID</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="Signature"><span class="BigBadge">Message</span>Signature</H3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.<BR>The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.<BR>This message is deprecated and succeeded by SignaturePair and SignatureMap messages.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>option</TD>
<TD><a href="#deprecated=true">deprecated=true</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD><P>ed25519 signature bytes</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD><P>RSA-3072 signature bytes</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD><P>ECDSA p-384 signature bytes</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD><P>A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD><P>A list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="SignatureList"><span class="BigBadge">Message</span>SignatureList</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>option</TD>
<TD><a href="#deprecated=true">deprecated=true</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a> (repeated)</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="SignatureMap"><span class="BigBadge">Message</span>SignatureMap</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigPair</TD>
<TD><a href="#SignaturePair">SignaturePair</a> (repeated)</TD>
<TD><P>Each signature pair corresponds to a unique Key required to sign the transaction.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="SignaturePair"><span class="BigBadge">Message</span>SignaturePair</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>pubKeyPrefix</TD>
<TD>bytes</TD>
<TD><P>First few bytes of the public key</P></TD>
</TR>

<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="SubType"><span class="BigBadge">Enum</span>SubType</H3>
<P><BR>Possible FeeData Object SubTypes. Supplementary to the main HederaFunctionality Type.<BR>When not explicitly specified, DEFAULT is used.</P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>DEFAULT</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>TOKEN_FUNGIBLE_COMMON</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>TOKEN_NON_FUNGIBLE_UNIQUE</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ThresholdKey"><span class="BigBadge">Message</span>ThresholdKey</H3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD><P>A valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD><P>List of all the keys that can sign</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ThresholdSignature"><span class="BigBadge">Message</span>ThresholdSignature</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>option</TD>
<TD><a href="#deprecated=true">deprecated=true</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenBalance"><span class="BigBadge">Message</span>TokenBalance</H3>
<P> A number of <i>transferable units</i> of a certain token.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>tokenId</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>A unique token id</P></TD>
</TR>

<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD><P>Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON - balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account</P></TD>
</TR>

<TR>
<TD>decimals</TD>
<TD>uint32</TD>
<TD><P>Tokens divide into <tt>10<sup>decimals</sup></tt> pieces</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenBalances"><span class="BigBadge">Message</span>TokenBalances</H3>
<P> A sequence of token balances </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>tokenBalances</TD>
<TD><a href="#TokenBalance">TokenBalance</a> (repeated)</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenFreezeStatus"><span class="BigBadge">Enum</span>TokenFreezeStatus</H3>
<P> Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>FreezeNotApplicable</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>Frozen</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>Unfrozen</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenID"><span class="BigBadge">Message</span>TokenID</H3>
<P> Unique identifier for a token </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative shard number</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative realm number</P></TD>
</TR>

<TR>
<TD>tokenNum</TD>
<TD>int64</TD>
<TD><P>A nonnegative token number</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenKycStatus"><span class="BigBadge">Enum</span>TokenKycStatus</H3>
<P> Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>KycNotApplicable</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>Granted</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>Revoked</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenRelationship"><span class="BigBadge">Message</span>TokenRelationship</H3>
<P> Token's information related to the given Account </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>tokenId</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The ID of the token</P></TD>
</TR>

<TR>
<TD>symbol</TD>
<TD>string</TD>
<TD><P>The Symbol of the token</P></TD>
</TR>

<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD><P>For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account</P></TD>
</TR>

<TR>
<TD>kycStatus</TD>
<TD><a href="#TokenKycStatus">TokenKycStatus</a></TD>
<TD><P>The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not have KYC key, KycNotApplicable is returned</P></TD>
</TR>

<TR>
<TD>freezeStatus</TD>
<TD><a href="#TokenFreezeStatus">TokenFreezeStatus</a></TD>
<TD><P>The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does not have Freeze key, FreezeNotApplicable is returned</P></TD>
</TR>

<TR>
<TD>decimals</TD>
<TD>uint32</TD>
<TD><P>Tokens divide into <tt>10<sup>decimals</sup></tt> pieces</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenSupplyType"><span class="BigBadge">Enum</span>TokenSupplyType</H3>
<P><BR>Possible Token Supply Types (IWA Compatibility).<BR>Indicates how many tokens can have during its lifetime.</P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>INFINITE</TD>
<TD><P>Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.</P></TD>
</TR>

<TR>
<TD>FINITE</TD>
<TD><P>Indicates that tokens of that type have an upper bound of maxSupply, provided on token creation.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenTransferList"><span class="BigBadge">Message</span>TokenTransferList</H3>
<P> A list of token IDs and amounts representing the transferred out (negative) or into (positive) amounts, represented in the lowest denomination of the token </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The ID of the token</P></TD>
</TR>

<TR>
<TD>transfers</TD>
<TD><a href="#AccountAmount">AccountAmount</a> (repeated)</TD>
<TD><P>Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which has an account and amount</P></TD>
</TR>

<TR>
<TD>nftTransfers</TD>
<TD><a href="#NftTransfer">NftTransfer</a> (repeated)</TD>
<TD><P>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of which has a sender and receiver account, including the serial number of the NFT</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenType"><span class="BigBadge">Enum</span>TokenType</H3>
<P><BR>Possible Token Types (IWA Compatibility).<BR>Apart from fungible and non-fungible, Tokens can have either a common or unique representation. This distinction might seem subtle, but it is important when considering<BR>how tokens can be traced and if they can have isolated and unique properties.</P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>*</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>*</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FUNGIBLE_COMMON</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>*</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>*</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>NON_FUNGIBLE_UNIQUE</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TopicID"><span class="BigBadge">Message</span>TopicID</H3>
<P> Unique identifier for a topic (used by the consensus service) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD><P>The shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD><P>The realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>topicNum</TD>
<TD>int64</TD>
<TD><P>Unique topic identifier within a realm (nonnegative).</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TransactionFeeSchedule"><span class="BigBadge">Message</span>TransactionFeeSchedule</H3>
<P> The fees for a specific transaction or query based on the fee data. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>hederaFunctionality</TD>
<TD><a href="#HederaFunctionality">HederaFunctionality</a></TD>
<TD><P> A particular transaction or query</P></TD>
</TR>

<TR>
<TD>feeData</TD>
<TD><a href="#FeeData">FeeData</a> (repeated)</TD>
<TD><P> Resource price coefficients</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TransactionID"><span class="BigBadge">Message</span>TransactionID</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID that paid for this transaction</P></TD>
</TR>

<TR>
<TD>scheduled</TD>
<TD>bool</TD>
<TD><P>Whether the Transaction is of type Scheduled or no</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TransferList"><span class="BigBadge">Message</span>TransferList</H3>
<P> A list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a> (repeated)</TD>
<TD><P>Multiple list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ConsensusCreateTopic.proto">ConsensusCreateTopic.proto</H2>
<a href="#title">Top</a>
</div>
<P> See [ConsensusService.createTopic()](#proto.ConsensusService)</P>
<H3 id="ConsensusCreateTopicTransactionBody"><span class="BigBadge">Message</span>ConsensusCreateTopicTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>Short publicly visible memo about the topic. No guarantee of uniqueness.</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P> Access control for updateTopic/deleteTopic.<BR>Anyone can increase the topic's expirationTime via ConsensusService.updateTopic(), regardless of the adminKey.<BR>If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic<BR>is disallowed.</P></TD>
</TR>

<TR>
<TD>submitKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P> Access control for submitMessage.<BR>If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed).</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P> The initial lifetime of the topic and the amount of time to attempt to extend the topic's lifetime by<BR>automatically at the topic's expirationTime, if the autoRenewAccount is configured (once autoRenew functionality<BR>is supported by HAPI).<BR>Limited to MIN_AUTORENEW_PERIOD and MAX_AUTORENEW_PERIOD value by server-side configuration.<BR>Required.</P></TD>
</TR>

<TR>
<TD>autoRenewAccount</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> Optional account to be used at the topic's expirationTime to extend the life of the topic (once autoRenew<BR>functionality is supported by HAPI).<BR>The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic<BR>can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension<BR>is possible with the account's funds).<BR>If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ConsensusDeleteTopic.proto">ConsensusDeleteTopic.proto</H2>
<a href="#title">Top</a>
</div>
<P> See [ConsensusService.deleteTopic()](#proto.ConsensusService)</P>
<H3 id="ConsensusDeleteTopicTransactionBody"><span class="BigBadge">Message</span>ConsensusDeleteTopicTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>topicID</TD>
<TD><a href="#TopicID">TopicID</a></TD>
<TD><P>Topic identifier.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ConsensusGetTopicInfo.proto">ConsensusGetTopicInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> See [ConsensusService.getTopicInfo()](#proto.ConsensusService)</P>
<H3 id="ConsensusGetTopicInfoQuery"><span class="BigBadge">Message</span>ConsensusGetTopicInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P> Standard info sent from client to node, including the signed payment, and what kind of response is requested<BR>(cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>topicID</TD>
<TD><a href="#TopicID">TopicID</a></TD>
<TD><P> The Topic for which information is being requested</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ConsensusGetTopicInfoResponse"><span class="BigBadge">Message</span>ConsensusGetTopicInfoResponse</H3>
<P> Retrieve the parameters of and state of a consensus topic.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P> Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.</P></TD>
</TR>

<TR>
<TD>topicID</TD>
<TD><a href="#TopicID">TopicID</a></TD>
<TD><P>Topic identifier.</P></TD>
</TR>

<TR>
<TD>topicInfo</TD>
<TD><a href="#ConsensusTopicInfo">ConsensusTopicInfo</a></TD>
<TD><P>Current state of the topic</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ConsensusService.proto">ConsensusService.proto</H2>
<a href="#title">Top</a>
</div>
<P> The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to the order and<BR>validity of messages submitted to a topic, as well as a consensus timestamp for those messages.<BR>Automatic renewal can be configured via an autoRenewAccount.<BR>Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must be signed by<BR>the autoRenewAccount.<BR>The autoRenewPeriod on an account must currently be set a value in createTopic between MIN_AUTORENEW_PERIOD (6999999<BR>seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During creation this sets the initial expirationTime of the<BR>topic (see more below).<BR>If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is not allowed,<BR>and the only change allowed via an updateTopic is to extend the expirationTime.<BR>If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the adminKey, except<BR>for updateTopics which only extend the topic's expirationTime (no adminKey authorization required).<BR>If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic must fulfill both<BR>the pre-update and post-update adminKey signature requirements.<BR>Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to the topic<BR>definition and the consensus ordering and timestamp of submitted messages.<BR>Until autoRenew functionality is supported by HAPI, the topic will not expire, the autoRenewAccount will not be<BR>charged, and the topic will not automatically be deleted.<BR>Once autoRenew functionality is supported by HAPI:<BR>1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the account will be<BR>charged automatically at the expirationTime, to extend the expirationTime of the topic up to the topic's<BR>autoRenewPeriod (or as much extension as the account's balance will supply).<BR>2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state. All transactions<BR>on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that modifies only the expirationTime.<BR>getTopicInfo() will succeed. This state will be available for a AUTORENEW_GRACE_PERIOD grace period (7 days).<BR>3. After the grace period, if the topic's expirationTime is not extended, the topic will be automatically<BR>deleted and no transactions or queries on the topic will succeed after that point.</P>
<H3 id="ConsensusService"><span class="BigBadge">Service</span>ConsensusService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>createTopic </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Create a topic to be used for consensus.<BR>If an autoRenewAccount is specified, that account must also sign this transaction.<BR>If an adminKey is specified, the adminKey must sign the transaction.<BR>On success, the resulting TransactionReceipt contains the newly created TopicId.<BR>Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)</P></TD>
</TR>

<TR>
<TD>updateTopic </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Update a topic.<BR>If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.<BR>Otherwise transaction must be signed by the adminKey.<BR>If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.<BR>If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.<BR>Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)</P></TD>
</TR>

<TR>
<TD>deleteTopic </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.<BR>If an adminKey is set, this transaction must be signed by that key.<BR>If there is no adminKey, this transaction will fail UNAUTHORIZED.<BR>Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)</P></TD>
</TR>

<TR>
<TD>getTopicInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.<BR>Deleted accounts will not be returned.<BR>Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)<BR>Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)</P></TD>
</TR>

<TR>
<TD>submitMessage </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Submit a message for consensus.<BR>Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the<BR>mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.<BR>The submitKey (if any) must sign this transaction.<BR>On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and<BR>topicRunningHash.<BR>Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ConsensusSubmitMessage.proto">ConsensusSubmitMessage.proto</H2>
<a href="#title">Top</a>
</div>
<P>-<BR>‌<BR>Hedera Network Services Protobuf<BR>​<BR>Copyright (C) 2018 - 2021 Hedera Hashgraph, LLC<BR>​<BR>Licensed under the Apache License, Version 2.0 (the "License");<BR>you may not use this file except in compliance with the License.<BR>You may obtain a copy of the License at<BR>http:www.apache.org/licenses/LICENSE-2.0<BR>Unless required by applicable law or agreed to in writing, software<BR>distributed under the License is distributed on an "AS IS" BASIS,<BR>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<BR>See the License for the specific language governing permissions and<BR>limitations under the License.<BR>‍</P>
<H3 id="ConsensusMessageChunkInfo"><span class="BigBadge">Message</span>ConsensusMessageChunkInfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>initialTransactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P>TransactionID of the first chunk, gets copied to every subsequent chunk in a fragmented message.</P></TD>
</TR>

<TR>
<TD>total</TD>
<TD>int32</TD>
<TD><P>The total number of chunks in the message.</P></TD>
</TR>

<TR>
<TD>number</TD>
<TD>int32</TD>
<TD><P>The sequence number (from 1 to total) of the current chunk in the message.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ConsensusSubmitMessageTransactionBody"><span class="BigBadge">Message</span>ConsensusSubmitMessageTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>topicID</TD>
<TD><a href="#TopicID">TopicID</a></TD>
<TD><P>Topic to submit message to.</P></TD>
</TR>

<TR>
<TD>message</TD>
<TD>bytes</TD>
<TD><P>Message to be submitted. Max size of the Transaction (including signatures) is 6KiB.</P></TD>
</TR>

<TR>
<TD>chunkInfo</TD>
<TD><a href="#ConsensusMessageChunkInfo">ConsensusMessageChunkInfo</a></TD>
<TD><P>Optional information of the current chunk in a fragmented message.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ConsensusTopicInfo.proto">ConsensusTopicInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Current state of a topic.</P>
<H3 id="ConsensusTopicInfo"><span class="BigBadge">Message</span>ConsensusTopicInfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo associated with the topic (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<TR>
<TD>runningHash</TD>
<TD>bytes</TD>
<TD><P> When a topic is created, its running hash is initialized to 48 bytes of binary zeros.<BR>For each submitted message, the topic's running hash is then updated to the output<BR>of a particular SHA-384 digest whose input data include the previous running hash.<BR><BR>See the TransactionReceipt.proto documentation for an exact description of the<BR>data included in the SHA-384 digest used for the update.</P></TD>
</TR>

<TR>
<TD>sequenceNumber</TD>
<TD>uint64</TD>
<TD><P> Sequence number (starting at 1 for the first submitMessage) of messages on the topic.</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P> Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic<BR>and the topic will expire and after AUTORENEW_GRACE_PERIOD be automatically deleted.</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>Access control for update/delete of the topic. Null if there is no key.</P></TD>
</TR>

<TR>
<TD>submitKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>Access control for ConsensusService.submitMessage. Null if there is no key.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>If an auto-renew account is specified, when the topic expires, its lifetime will be extended by up to this duration (depending on the solvency of the auto-renew account). If the auto-renew account has no funds at all, the topic will be deleted instead.</P></TD>
</TR>

<TR>
<TD>autoRenewAccount</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account, if any, to charge for automatic renewal of the topic's lifetime upon expiry.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ConsensusUpdateTopic.proto">ConsensusUpdateTopic.proto</H2>
<a href="#title">Top</a>
</div>
<P> All fields left null will not be updated.<BR>See [ConsensusService.updateTopic()](#proto.ConsensusService)</P>
<H3 id="ConsensusUpdateTopicTransactionBody"><span class="BigBadge">Message</span>ConsensusUpdateTopicTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>topicID</TD>
<TD><a href="#TopicID">TopicID</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></TD>
<TD><P>If set, the new memo to be associated with the topic (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P> Effective consensus timestamp at (and after) which all consensus transactions and queries will fail.<BR>The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of<BR>this transaction.<BR>On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.<BR>If unspecified, no change.</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P> Access control for update/delete of the topic.<BR>If unspecified, no change.<BR>If empty keyList - the adminKey is cleared.</P></TD>
</TR>

<TR>
<TD>submitKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P> Access control for ConsensusService.submitMessage.<BR>If unspecified, no change.<BR>If empty keyList - the submitKey is cleared.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P> The amount of time to extend the topic's lifetime automatically at expirationTime if the autoRenewAccount is<BR>configured and has funds (once autoRenew functionality is supported by HAPI).<BR>Limited to between MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds) by<BR>servers-side configuration (which may change).<BR>If unspecified, no change.</P></TD>
</TR>

<TR>
<TD>autoRenewAccount</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> Optional account to be used at the topic's expirationTime to extend the life of the topic.<BR>Once autoRenew functionality is supported by HAPI, the topic lifetime will be extended up to a maximum of the<BR>autoRenewPeriod or however long the topic can be extended using all funds on the account (whichever is the<BR>smaller duration/amount).<BR>If specified as the default value (0.0.0), the autoRenewAccount will be removed.<BR>If unspecified, no change.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractCall.proto">ContractCall.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractCallTransactionBody"><span class="BigBadge">Message</span>ContractCallTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractCallLocal.proto">ContractCallLocal.proto</H2>
<a href="#title">Top</a>
</div>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<H3 id="ContractCallLocalQuery"><span class="BigBadge">Message</span>ContractCallLocalQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered.</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD><P>The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<TR>
<TD>maxResultSize</TD>
<TD>int64</TD>
<TD><P>max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractCallLocalResponse"><span class="BigBadge">Message</span>ContractCallLocalResponse</H3>
<P> Response when the client sends the node ContractCallLocalQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>functionResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD><P>the value returned by the function (if it completed and didn't fail)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractFunctionResult"><span class="BigBadge">Message</span>ContractFunctionResult</H3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD><P>units of gas used to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a> (repeated)</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>createdContractIDs</TD>
<TD><a href="#ContractID">ContractID</a> (repeated)</TD>
<TD><P>the list of smart contracts that were created by the function call</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractLoginfo"><span class="BigBadge">Message</span>ContractLoginfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes (repeated)</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractCreate.proto">ContractCreate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractCreateTransactionBody"><span class="BigBadge">Message</span>ContractCreateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node, then it will behave as if  proxyAccountID was null.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>the memo that was submitted as part of the contract (max 100 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractDelete.proto">ContractDelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractDeleteTransactionBody"><span class="BigBadge">Message</span>ContractDeleteTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P> The id of the contract to be deleted</P></TD>
</TR>

<TR>
<TD>obtainers</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> The id of an account to receive any remaining hBars from the deleted contract</P></TD>
</TR>

<TR>
<TD>transferContractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P> The id of a contract to receive any remaining hBars from the deleted contract</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractGetBytecode.proto">ContractGetBytecode.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the bytecode for a smart contract instance </P>
<H3 id="ContractGetBytecodeQuery"><span class="BigBadge">Message</span>ContractGetBytecodeQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>the contract for which information is requested</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractGetBytecodeResponse"><span class="BigBadge">Message</span>ContractGetBytecodeResponse</H3>
<P> Response when the client sends the node ContractGetBytecodeQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>bytecode</TD>
<TD>bytes</TD>
<TD><P>the bytecode</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractGetInfo.proto">ContractGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get information about a smart contract instance. This includes the account that it uses, the file containing its bytecode, and the time when it will expire. </P>
<H3 id="ContractGetInfoQuery"><span class="BigBadge">Message</span>ContractGetInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>the contract for which information is requested</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractGetInfoResponse"><span class="BigBadge">Message</span>ContractGetInfoResponse</H3>
<P> Response when the client sends the node ContractGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>contractInfo</TD>
<TD><a href="#ContractGetInfoResponse.ContractInfo">ContractGetInfoResponse.ContractInfo</a></TD>
<TD><P>the information about this contract instance (a state proof can be generated for this)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractGetInfoResponse.ContractInfo"><span class="BigBadge">Message</span>ContractGetInfoResponse.ContractInfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>ID of the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>ID of the cryptocurrency account owned by the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD><P>ID of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>the current time at which this contract instance (and its account) is set to expire</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>the expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If the account is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>storage</TD>
<TD>int64</TD>
<TD><P>number of bytes of storage being used by this instance (which affects the cost to extend the expiration time)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>the memo associated with the contract (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD><P>The current balance, in tinybars</P></TD>
</TR>

<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD><P>Whether the contract has been deleted</P></TD>
</TR>

<TR>
<TD>tokenRelationships</TD>
<TD><a href="#TokenRelationship">TokenRelationship</a> (repeated)</TD>
<TD><P>The tokens associated to the contract</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractGetRecords.proto">ContractGetRecords.proto</H2>
<a href="#title">Top</a>
</div>
<P> Before v0.9.0, requested records of all transactions against the given contract in the last 25 hours.</P>
<H3 id="ContractGetRecordsQuery"><span class="BigBadge">Message</span>ContractGetRecordsQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>option</TD>
<TD><a href="#deprecated=true">deprecated=true</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>The smart contract instance for which the records should be retrieved</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractGetRecordsResponse"><span class="BigBadge">Message</span>ContractGetRecordsResponse</H3>
<P> Before v0.9.0, returned records of all transactions against the given contract in the last 25 hours.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>option</TD>
<TD><a href="#deprecated=true">deprecated=true</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>The smart contract instance that this record is for</P></TD>
</TR>

<TR>
<TD>records</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a> (repeated)</TD>
<TD><P>List of records, each with contractCreateResult or contractCallResult as its body</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractUpdate.proto">ContractUpdate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractUpdateTransactionBody"><span class="BigBadge">Message</span>ContractUpdateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P> The id of the contract to be updated</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P> The new expiry of the contract, no earlier than the current expiry (resolves to EXPIRATION_REDUCTION_NOT_ALLOWED otherwise)</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P> The new key to control updates to the contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> (NOT YET IMPLEMENTED) The new id of the account to which the contract is proxy staked</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P> (NOT YET IMPLEMENTED) The new interval at which the contract will pay to extend its expiry (by the same interval)</P></TD>
</TR>

<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P> The new id of the file asserted to contain the bytecode of the Solidity transaction that created this contract</P></TD>
</TR>

<TR>
<TD>memoField</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>[Deprecated] If set with a non-zero length, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<TR>
<TD>memoWrapper</TD>
<TD><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></TD>
<TD><P>If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoAddLiveHash.proto">CryptoAddLiveHash.proto</H2>
<a href="#title">Top</a>
</div>
<P> A hash---presumably of some kind of credential or certificate---along with a list of keys, each of which may be either a primitive or a threshold key. </P>
<H3 id="CryptoAddLiveHashTransactionBody"><span class="BigBadge">Message</span>CryptoAddLiveHashTransactionBody</H3>
<P> At consensus, attaches the given livehash to the given account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>liveHash</TD>
<TD><a href="#LiveHash">LiveHash</a></TD>
<TD><P> A hash of some credential or certificate, along with the keys of the entities that asserted it validity</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="LiveHash"><span class="BigBadge">Message</span>LiveHash</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountId</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> The account to which the livehash is attached</P></TD>
</TR>

<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD><P> The SHA-384 hash of a credential or certificate</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD><P> A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it.</P></TD>
</TR>

<TR>
<TD>duration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P> The duration for which the livehash will remain valid</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoCreate.proto">CryptoCreate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoCreateTransactionBody"><span class="BigBadge">Message</span>CryptoCreateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD><P>The initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node, then it will behave as if proxyAccountID was null.</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD><P>[Deprecated]. The threshold amount (in tinybars) for which an account record is created for any send/withdraw transaction</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD><P>[Deprecated]. The threshold amount (in tinybars) for which an account record is created for any receive/deposit transaction</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD><P>If true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals)</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>The account is charged to extend its expiration date every this many seconds. If it doesn't have enough balance, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD><P>The shard in which this account is created</P></TD>
</TR>

<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD><P>The realm in which this account is created (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>If realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo associated with the account (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoDelete.proto">CryptoDelete.proto</H2>
<a href="#title">Top</a>
</div>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<H3 id="CryptoDeleteTransactionBody"><span class="BigBadge">Message</span>CryptoDeleteTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID which will receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID which should be deleted</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoDeleteLiveHash.proto">CryptoDeleteLiveHash.proto</H2>
<a href="#title">Top</a>
</div>
<P> At consensus, deletes a livehash associated to the given account. The transaction must be signed by either the key of the owning account, or at least one of the keys associated to the livehash. </P>
<H3 id="CryptoDeleteLiveHashTransactionBody"><span class="BigBadge">Message</span>CryptoDeleteLiveHashTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountOfLiveHash</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> The account owning the livehash</P></TD>
</TR>

<TR>
<TD>liveHashToDelete</TD>
<TD>bytes</TD>
<TD><P> The SHA-384 livehash to delete from the account</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetAccountBalance.proto">CryptoGetAccountBalance.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the balance of a cryptocurrency account. This returns only the balance, so it is a smaller</P>
<H3 id="CryptoGetAccountBalanceQuery"><span class="BigBadge">Message</span>CryptoGetAccountBalanceQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>balanceSource</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID for which information is requested</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>The account ID for which information is requested</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="CryptoGetAccountBalanceResponse"><span class="BigBadge">Message</span>CryptoGetAccountBalanceResponse</H3>
<P> Response when the client sends the node CryptoGetAccountBalanceQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID that is being described (this is useful with state proofs, for proving to a third party)</P></TD>
</TR>

<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD><P>The current balance, in tinybars.</P></TD>
</TR>

<TR>
<TD>tokenBalances</TD>
<TD><a href="#TokenBalance">TokenBalance</a> (repeated)</TD>
<TD><P>The token balances possessed by the target account.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetAccountRecords.proto">CryptoGetAccountRecords.proto</H2>
<a href="#title">Top</a>
</div>
<P> Requests records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.</P>
<H3 id="CryptoGetAccountRecordsQuery"><span class="BigBadge">Message</span>CryptoGetAccountRecordsQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID for which the records should be retrieved</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoGetAccountRecordsResponse"><span class="BigBadge">Message</span>CryptoGetAccountRecordsResponse</H3>
<P> Returns records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account that this record is for</P></TD>
</TR>

<TR>
<TD>records</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a> (repeated)</TD>
<TD><P>List of records</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetInfo.proto">CryptoGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get all the information about an account, including the balance. This does not get the list of account records. </P>
<H3 id="CryptoGetInfoQuery"><span class="BigBadge">Message</span>CryptoGetInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID for which information is requested</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoGetInfoResponse"><span class="BigBadge">Message</span>CryptoGetInfoResponse</H3>
<P> Response when the client sends the node CryptoGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>accountInfo</TD>
<TD><a href="#CryptoGetInfoResponse.AccountInfo">CryptoGetInfoResponse.AccountInfo</a></TD>
<TD><P>Info about the account (a state proof can be generated for this)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoGetInfoResponse.AccountInfo"><span class="BigBadge">Message</span>CryptoGetInfoResponse.AccountInfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID for which this information applies</P></TD>
</TR>

<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD><P>The Contract Account ID comprising of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD><P>If true, then this account has been deleted, it will disappear when it expires, and all transactions for it will fail except the transaction to extend its expiration date</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID of the account to which this is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node, then it will behave as if proxyAccountID was null.</P></TD>
</TR>

<TR>
<TD>proxyReceived</TD>
<TD>int64</TD>
<TD><P>The total number of tinybars proxy staked to this account</P></TD>
</TR>

<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key for the account, which must sign in order to transfer out, or to modify the account in any way other than extending its expiration date.</P></TD>
</TR>

<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD><P>The current balance of account in tinybars</P></TD>
</TR>

<TR>
<TD>generateSendRecordThreshold</TD>
<TD>uint64</TD>
<TD><P> [Deprecated]. The threshold amount, in tinybars, at which a record is created of any transaction that decreases the balance of this account by more than the threshold</P></TD>
</TR>

<TR>
<TD>generateReceiveRecordThreshold</TD>
<TD>uint64</TD>
<TD><P> [Deprecated]. The threshold amount, in tinybars, at which a record is created of any transaction that increases the balance of this account by more than the threshold</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD><P>If true, no transaction can transfer to this account unless signed by this account's key</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The TimeStamp time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>The duration for expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>liveHashes</TD>
<TD><a href="#LiveHash">LiveHash</a> (repeated)</TD>
<TD><P>All of the livehashes attached to the account (each of which is a hash along with the keys that authorized it and can delete it)</P></TD>
</TR>

<TR>
<TD>tokenRelationships</TD>
<TD><a href="#TokenRelationship">TokenRelationship</a> (repeated)</TD>
<TD><P>All tokens related to this account</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo associated with the account</P></TD>
</TR>

<TR>
<TD>ownedNfts</TD>
<TD>int64</TD>
<TD><P>The number of NFTs owned by this account</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetLiveHash.proto">CryptoGetLiveHash.proto</H2>
<a href="#title">Top</a>
</div>
<P> Requests a livehash associated to an account. </P>
<H3 id="CryptoGetLiveHashQuery"><span class="BigBadge">Message</span>CryptoGetLiveHashQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P> Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> The account to which the livehash is associated</P></TD>
</TR>

<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD><P> The SHA-384 data in the livehash</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoGetLiveHashResponse"><span class="BigBadge">Message</span>CryptoGetLiveHashResponse</H3>
<P> Returns the full livehash associated to an account, if it is present. Note that the only way to obtain a state proof exhibiting the absence of a livehash from an account is to retrieve a state proof of the entire account with its list of livehashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P> Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>liveHash</TD>
<TD><a href="#LiveHash">LiveHash</a></TD>
<TD><P> The livehash, if present</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetStakers.proto">CryptoGetStakers.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get all the accounts that are proxy staking to this account. For each of them, give the amount currently staked. This is not yet implemented, but will be in a future version of the API. </P>
<H3 id="AllProxyStakers"><span class="BigBadge">Message</span>AllProxyStakers</H3>
<P> all of the accounts proxy staking to a given account, and the amounts proxy staked </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID that is being proxy staked to</P></TD>
</TR>

<TR>
<TD>proxyStaker</TD>
<TD><a href="#ProxyStaker">ProxyStaker</a> (repeated)</TD>
<TD><P>Each of the proxy staking accounts, and the amount they are proxy staking</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoGetStakersQuery"><span class="BigBadge">Message</span>CryptoGetStakersQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID for which the records should be retrieved</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoGetStakersResponse"><span class="BigBadge">Message</span>CryptoGetStakersResponse</H3>
<P> Response when the client sends the node CryptoGetStakersQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>stakers</TD>
<TD><a href="#AllProxyStakers">AllProxyStakers</a></TD>
<TD><P>List of accounts proxy staking to this account, and the amount each is currently proxy staking</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ProxyStaker"><span class="BigBadge">Message</span>ProxyStaker</H3>
<P> information about a single account that is proxy staking </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID that is proxy staking</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD><P>The number of hbars that are currently proxy staked</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoService.proto">CryptoService.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoService"><span class="BigBadge">Service</span>CryptoService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>createAccount </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Creates a new account by submitting the transaction</P></TD>
</TR>

<TR>
<TD>updateAccount </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Updates an account by submitting the transaction</P></TD>
</TR>

<TR>
<TD>cryptoTransfer </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Initiates a transfer by submitting the transaction</P></TD>
</TR>

<TR>
<TD>cryptoDelete </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Deletes and account by submitting the transaction</P></TD>
</TR>

<TR>
<TD>addLiveHash </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> (NOT CURRENTLY SUPPORTED) Adds a livehash</P></TD>
</TR>

<TR>
<TD>deleteLiveHash </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> (NOT CURRENTLY SUPPORTED) Deletes a livehash</P></TD>
</TR>

<TR>
<TD>getLiveHash </TD><TD>Query</TD><TD>Response</TD><TD><P> (NOT CURRENTLY SUPPORTED) Retrieves a livehash for an account</P></TD>
</TR>

<TR>
<TD>getAccountRecords </TD><TD>Query</TD><TD>Response</TD><TD><P> Returns all transactions in the last 180s of consensus time for which the given account was the effective payer <b>and</b> network property <tt>ledger.keepRecordsInState</tt> was <tt>true</tt>.</P></TD>
</TR>

<TR>
<TD>cryptoGetBalance </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the balance of an account</P></TD>
</TR>

<TR>
<TD>getAccountInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the metadata of an account</P></TD>
</TR>

<TR>
<TD>getTransactionReceipts </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the latest receipt for a transaction that is either awaiting consensus, or reached consensus in the last 180 seconds</P></TD>
</TR>

<TR>
<TD>getFastTransactionRecord </TD><TD>Query</TD><TD>Response</TD><TD><P> (NOT CURRENTLY SUPPORTED) Returns the records of transactions recently funded by an account</P></TD>
</TR>

<TR>
<TD>getTxRecordByTxID </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the record of a transaction that is either awaiting consensus, or reached consensus in the last 180 seconds</P></TD>
</TR>

<TR>
<TD>getStakersByAccountID </TD><TD>Query</TD><TD>Response</TD><TD><P> (NOT CURRENTLY SUPPORTED) Retrieves the stakers for a node by account id</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoTransfer.proto">CryptoTransfer.proto</H2>
<a href="#title">Top</a>
</div>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar).</P>
<H3 id="CryptoTransferTransactionBody"><span class="BigBadge">Message</span>CryptoTransferTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tokenTransfers</TD>
<TD><a href="#TokenTransferList">TokenTransferList</a> (repeated)</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoUpdate.proto">CryptoUpdate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoUpdateTransactionBody"><span class="BigBadge">Message</span>CryptoUpdateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account ID which is being updated in this transaction</P></TD>
</TR>

<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The new key</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node, then it will behave as if proxyAccountID was null.</P></TD>
</TR>

<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD><P>[Deprecated]. Payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThresholdField</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD><P>[Deprecated]. The new threshold amount (in tinybars) for which an account record is created for any send/withdraw transaction</P></TD>
</TR>

<TR>
<TD>sendRecordThresholdWrapper</TD>
<TD><a href="#google.protobuf.UInt64Value">google.protobuf.UInt64Value</a></TD>
<TD><P>[Deprecated]. The new threshold amount (in tinybars) for which an account record is created for any send/withdraw transaction</P></TD>
</TR>

<tbody>
</TABLE>
<TR>
<TD>receiveRecordThresholdField</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD><P>[Deprecated]. The new threshold amount (in tinybars) for which an account record is created for any receive/deposit transaction.</P></TD>
</TR>

<TR>
<TD>receiveRecordThresholdWrapper</TD>
<TD><a href="#google.protobuf.UInt64Value">google.protobuf.UInt64Value</a></TD>
<TD><P>[Deprecated]. The new threshold amount (in tinybars) for which an account record is created for any receive/deposit transaction.</P></TD>
</TR>

<tbody>
</TABLE>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>The duration in which it will automatically extend the expiration period. If it doesn't have enough balance, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>receiverSigRequiredField</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD><P>[Deprecated] Do NOT use this field to set a false value because the server cannot distinguish from the default value. Use receiverSigRequiredWrapper field for this purpose.</P></TD>
</TR>

<TR>
<TD>receiverSigRequiredWrapper</TD>
<TD><a href="#google.protobuf.BoolValue">google.protobuf.BoolValue</a></TD>
<TD><P>If true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals)</P></TD>
</TR>

<tbody>
</TABLE>
<TR>
<TD>memo</TD>
<TD><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></TD>
<TD><P>If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Duration.proto">Duration.proto</H2>
<a href="#title">Top</a>
</div>
<P> A length of time in seconds. </P>
<H3 id="Duration"><span class="BigBadge">Message</span>Duration</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD><P>The number of seconds</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ExchangeRate.proto">ExchangeRate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ExchangeRate"><span class="BigBadge">Message</span>ExchangeRate</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>hbarEquiv</TD>
<TD>int32</TD>
<TD><P> Denominator in calculation of exchange rate between hbar and cents</P></TD>
</TR>

<TR>
<TD>centEquiv</TD>
<TD>int32</TD>
<TD><P> Numerator in calculation of exchange rate between hbar and cents</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD><P> Expiration time in seconds for this exchange rate</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ExchangeRateSet"><span class="BigBadge">Message</span>ExchangeRateSet</H3>
<P> Two sets of exchange rates </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>currentRate</TD>
<TD><a href="#ExchangeRate">ExchangeRate</a></TD>
<TD><P> Current exchange rate</P></TD>
</TR>

<TR>
<TD>nextRate</TD>
<TD><a href="#ExchangeRate">ExchangeRate</a></TD>
<TD><P> Next exchange rate which will take effect when current rate expires</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileAppend.proto">FileAppend.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileAppendTransactionBody"><span class="BigBadge">Message</span>FileAppendTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P> The file to which the bytes will be appended</P></TD>
</TR>

<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD><P> The bytes that will be appended to the end of the specified file</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileCreate.proto">FileCreate.proto</H2>
<a href="#title">Top</a>
</div>
<P> Create a new file, containing the given contents.</P>
<H3 id="FileCreateTransactionBody"><span class="BigBadge">Message</span>FileCreateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD><P>All these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD><P>The bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD><P>Shard in which this file is created</P></TD>
</TR>

<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD><P>The Realm in which to the file is created (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>If realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo associated with the file (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileDelete.proto">FileDelete.proto</H2>
<a href="#title">Top</a>
</div>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<H3 id="FileDeleteTransactionBody"><span class="BigBadge">Message</span>FileDeleteTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileGetContents.proto">FileGetContents.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the contents of a file. The content field is empty (no bytes) if the file is empty. </P>
<H3 id="FileGetContentsQuery"><span class="BigBadge">Message</span>FileGetContentsQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file ID of the file whose contents are requested</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FileGetContentsResponse"><span class="BigBadge">Message</span>FileGetContentsResponse</H3>
<P> Response when the client sends the node FileGetContentsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>fileContents</TD>
<TD><a href="#FileGetContentsResponse.FileContents">FileGetContentsResponse.FileContents</a></TD>
<TD><P>the file ID and contents (a state proof can be generated for this)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FileGetContentsResponse.FileContents"><span class="BigBadge">Message</span>FileGetContentsResponse.FileContents</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file ID of the file whose contents are being returned</P></TD>
</TR>

<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD><P>The bytes contained in the file</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileGetInfo.proto">FileGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get all of the information about a file, except for its contents. When a file expires, it no longer exists, and there will be no info about it, and the fileInfo field will be blank. If a transaction or smart contract deletes the file, but it has not yet expired, then the fileInfo field will be non-empty, the deleted field will be true, its size will be 0, and its contents will be empty. </P>
<H3 id="FileGetInfoQuery"><span class="BigBadge">Message</span>FileGetInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file ID of the file for which information is requested</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FileGetInfoResponse"><span class="BigBadge">Message</span>FileGetInfoResponse</H3>
<P> Response when the client sends the node FileGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>fileInfo</TD>
<TD><a href="#FileGetInfoResponse.FileInfo">FileGetInfoResponse.FileInfo</a></TD>
<TD><P>The information about the file</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FileGetInfoResponse.FileInfo"><span class="BigBadge">Message</span>FileGetInfoResponse.FileInfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file ID of the file for which information is requested</P></TD>
</TR>

<TR>
<TD>size</TD>
<TD>int64</TD>
<TD><P>Number of bytes in contents</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The current time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD><P>True if deleted but not yet expired</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD><P>One of these keys must sign in order to modify or delete the file</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo associated with the file</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileService.proto">FileService.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileService"><span class="BigBadge">Service</span>FileService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>createFile </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Creates a file</P></TD>
</TR>

<TR>
<TD>updateFile </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Updates a file</P></TD>
</TR>

<TR>
<TD>deleteFile </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Deletes a file</P></TD>
</TR>

<TR>
<TD>appendContent </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Appends to a file</P></TD>
</TR>

<TR>
<TD>getFileContent </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the file contents</P></TD>
</TR>

<TR>
<TD>getFileInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the file information</P></TD>
</TR>

<TR>
<TD>systemDelete </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Deletes a file if the submitting account has network admin privileges</P></TD>
</TR>

<TR>
<TD>systemUndelete </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Undeletes a file if the submitting account has network admin privileges</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileUpdate.proto">FileUpdate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileUpdateTransactionBody"><span class="BigBadge">Message</span>FileUpdateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The ID of the file to update</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The new expiry time (ignored if not later than the current expiry)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD><P>The new list of keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD><P>The new contents that should overwrite the file's current contents</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></TD>
<TD><P>If set, the new memo to be associated with the file (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Freeze.proto">Freeze.proto</H2>
<a href="#title">Top</a>
</div>
<P> Set the freezing period in which the platform will stop creating events and accepting transactions. This is used before safely shut down the platform for maintenance. </P>
<H3 id="FreezeTransactionBody"><span class="BigBadge">Message</span>FreezeTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>startHour</TD>
<TD>int32</TD>
<TD><P>The start hour (in UTC time), a value between 0 and 23</P></TD>
</TR>

<TR>
<TD>startMin</TD>
<TD>int32</TD>
<TD><P>The start minute (in UTC time), a value between 0 and 59</P></TD>
</TR>

<TR>
<TD>endHour</TD>
<TD>int32</TD>
<TD><P>The end hour (in UTC time), a value between 0 and 23</P></TD>
</TR>

<TR>
<TD>endMin</TD>
<TD>int32</TD>
<TD><P>The end minute (in UTC time), a value between 0 and 59</P></TD>
</TR>

<TR>
<TD>updateFile</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The ID of the file needs to be updated during a freeze transaction</P></TD>
</TR>

<TR>
<TD>fileHash</TD>
<TD>bytes</TD>
<TD><P>The hash value of the file, used to verify file content before performing freeze and update</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FreezeService.proto">FreezeService.proto</H2>
<a href="#title">Top</a>
</div>
<P> The request and responses for freeze service. </P>
<H3 id="FreezeService"><span class="BigBadge">Service</span>FreezeService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>freeze </TD><TD>Transaction</TD><TD>TransactionResponse</TD>Freezes the nodes by submitting the transaction. The grpc server returns the TransactionResponse<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="GetByKey.proto">GetByKey.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get all accounts, claims, files, and smart contract instances whose associated keys include the given Key. The given Key must not be a contractID or a ThresholdKey. This is not yet implemented in the API, but will be in the future. </P>
<H3 id="EntityID"><span class="BigBadge">Message</span>EntityID</H3>
<P> the ID for a single entity (account, livehash, file, or smart contract instance) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>entity</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID for the cryptocurrency account</P></TD>
</TR>

<TR>
<TD>liveHash</TD>
<TD><a href="#LiveHash">LiveHash</a></TD>
<TD><P>A uniquely identifying livehash of an acount</P></TD>
</TR>

<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file ID of the file</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>The smart contract ID that identifies instance</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="GetByKeyQuery"><span class="BigBadge">Message</span>GetByKeyQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key to search for. It must not contain a contractID nor a ThresholdSignature.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="GetByKeyResponse"><span class="BigBadge">Message</span>GetByKeyResponse</H3>
<P> Response when the client sends the node GetByKeyQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>entities</TD>
<TD><a href="#EntityID">EntityID</a> (repeated)</TD>
<TD><P>The list of entities that include this public key in their associated Key list</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="GetBySolidityID.proto">GetBySolidityID.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the IDs in the format used by transactions, given the ID in the format used by Solidity. If the Solidity ID is for a smart contract instance, then both the ContractID and associated AccountID will be returned. </P>
<H3 id="GetBySolidityIDQuery"><span class="BigBadge">Message</span>GetBySolidityIDQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>solidityID</TD>
<TD>string</TD>
<TD><P>The ID in the format used by Solidity</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="GetBySolidityIDResponse"><span class="BigBadge">Message</span>GetBySolidityIDResponse</H3>
<P> Response when the client sends the node GetBySolidityIDQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account ID for the cryptocurrency account</P></TD>
</TR>

<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file Id for the file</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>A smart contract ID for the instance (if this is included, then the associated accountID will also be included)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="NetworkGetVersionInfo.proto">NetworkGetVersionInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the deployed versions of Hedera Services and the HAPI proto in semantic version format </P>
<H3 id="NetworkGetVersionInfoQuery"><span class="BigBadge">Message</span>NetworkGetVersionInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="NetworkGetVersionInfoResponse"><span class="BigBadge">Message</span>NetworkGetVersionInfoResponse</H3>
<P> Response when the client sends the node NetworkGetVersionInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>hapiProtoVersion</TD>
<TD><a href="#SemanticVersion">SemanticVersion</a></TD>
<TD><P>The Hedera API (HAPI) protobuf version recognized by the responding node.</P></TD>
</TR>

<TR>
<TD>hederaServicesVersion</TD>
<TD><a href="#SemanticVersion">SemanticVersion</a></TD>
<TD><P>The version of the Hedera Services software deployed on the responding node.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="NetworkService.proto">NetworkService.proto</H2>
<a href="#title">Top</a>
</div>
<P> The requests and responses for different network services. </P>
<H3 id="NetworkService"><span class="BigBadge">Service</span>NetworkService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>getVersionInfo </TD><TD>Query</TD><TD>Response</TD>Retrieves the active versions of Hedera Services and HAPI proto<TD><P></P></TD>
</TR>

<TR>
<TD>uncheckedSubmit </TD><TD>Transaction</TD><TD>TransactionResponse</TD>Submits a "wrapped" transaction to the network, skipping its standard prechecks. (Note that the "wrapper" <tt>UncheckedSubmit</tt> transaction is still subject to normal prechecks, including an authorization requirement that its payer be either the treasury or system admin account.)<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Query.proto">Query.proto</H2>
<a href="#title">Top</a>
</div>
<P> A single query, which is sent from the client to a node. This includes all possible queries. Each Query should not have more than 50 levels. </P>
<H3 id="Query"><span class="BigBadge">Message</span>Query</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>query</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>getByKey</TD>
<TD><a href="#GetByKeyQuery">GetByKeyQuery</a></TD>
<TD><P>Get all entities associated with a given key</P></TD>
</TR>

<TR>
<TD>getBySolidityID</TD>
<TD><a href="#GetBySolidityIDQuery">GetBySolidityIDQuery</a></TD>
<TD><P>Get the IDs in the format used in transactions, given the format used in Solidity</P></TD>
</TR>

<TR>
<TD>contractCallLocal</TD>
<TD><a href="#ContractCallLocalQuery">ContractCallLocalQuery</a></TD>
<TD><P>Call a function of a smart contract instance</P></TD>
</TR>

<TR>
<TD>contractGetInfo</TD>
<TD><a href="#ContractGetInfoQuery">ContractGetInfoQuery</a></TD>
<TD><P>Get information about a smart contract instance</P></TD>
</TR>

<TR>
<TD>contractGetBytecode</TD>
<TD><a href="#ContractGetBytecodeQuery">ContractGetBytecodeQuery</a></TD>
<TD><P>Get bytecode used by a smart contract instance</P></TD>
</TR>

<TR>
<TD>ContractGetRecords</TD>
<TD><a href="#ContractGetRecordsQuery">ContractGetRecordsQuery</a></TD>
<TD><P>Get Records of the contract instance</P></TD>
</TR>

<TR>
<TD>cryptogetAccountBalance</TD>
<TD><a href="#CryptoGetAccountBalanceQuery">CryptoGetAccountBalanceQuery</a></TD>
<TD><P>Get the current balance in a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>cryptoGetAccountRecords</TD>
<TD><a href="#CryptoGetAccountRecordsQuery">CryptoGetAccountRecordsQuery</a></TD>
<TD><P>Get all the records that currently exist for transactions involving an account</P></TD>
</TR>

<TR>
<TD>cryptoGetInfo</TD>
<TD><a href="#CryptoGetInfoQuery">CryptoGetInfoQuery</a></TD>
<TD><P>Get all information about an account</P></TD>
</TR>

<TR>
<TD>cryptoGetLiveHash</TD>
<TD><a href="#CryptoGetLiveHashQuery">CryptoGetLiveHashQuery</a></TD>
<TD><P>Get a single livehash from a single account, if present</P></TD>
</TR>

<TR>
<TD>cryptoGetProxyStakers</TD>
<TD><a href="#CryptoGetStakersQuery">CryptoGetStakersQuery</a></TD>
<TD><P>Get all the accounts that proxy stake to a given account, and how much they proxy stake (not yet implemented in the current API)</P></TD>
</TR>

<TR>
<TD>fileGetContents</TD>
<TD><a href="#FileGetContentsQuery">FileGetContentsQuery</a></TD>
<TD><P>Get the contents of a file (the bytes stored in it)</P></TD>
</TR>

<TR>
<TD>fileGetInfo</TD>
<TD><a href="#FileGetInfoQuery">FileGetInfoQuery</a></TD>
<TD><P>Get information about a file, such as its expiration date</P></TD>
</TR>

<TR>
<TD>transactionGetReceipt</TD>
<TD><a href="#TransactionGetReceiptQuery">TransactionGetReceiptQuery</a></TD>
<TD><P>Get a receipt for a transaction (lasts 180 seconds)</P></TD>
</TR>

<TR>
<TD>transactionGetRecord</TD>
<TD><a href="#TransactionGetRecordQuery">TransactionGetRecordQuery</a></TD>
<TD><P>Get a record for a transaction</P></TD>
</TR>

<TR>
<TD>transactionGetFastRecord</TD>
<TD><a href="#TransactionGetFastRecordQuery">TransactionGetFastRecordQuery</a></TD>
<TD><P>Get a record for a transaction (lasts 180 seconds)</P></TD>
</TR>

<TR>
<TD>consensusGetTopicInfo</TD>
<TD><a href="#ConsensusGetTopicInfoQuery">ConsensusGetTopicInfoQuery</a></TD>
<TD><P>Get the parameters of and state of a consensus topic.</P></TD>
</TR>

<TR>
<TD>networkGetVersionInfo</TD>
<TD><a href="#NetworkGetVersionInfoQuery">NetworkGetVersionInfoQuery</a></TD>
<TD><P>Get the versions of the HAPI protobuf and Hedera Services software deployed on the responding node.</P></TD>
</TR>

<TR>
<TD>tokenGetInfo</TD>
<TD><a href="#TokenGetInfoQuery">TokenGetInfoQuery</a></TD>
<TD><P>Get all information about a token</P></TD>
</TR>

<TR>
<TD>scheduleGetInfo</TD>
<TD><a href="#ScheduleGetInfoQuery">ScheduleGetInfoQuery</a></TD>
<TD><P>Get all information about a scheduled entity</P></TD>
</TR>

<TR>
<TD>tokenGetAccountNftInfo</TD>
<TD><a href="#TokenGetAccountNftInfoQuery">TokenGetAccountNftInfoQuery</a></TD>
<TD><P>Get a list of NFTs associated with the account</P></TD>
</TR>

<TR>
<TD>tokenGetNftInfo</TD>
<TD><a href="#TokenGetNftInfoQuery">TokenGetNftInfoQuery</a></TD>
<TD><P>Get all information about a NFT</P></TD>
</TR>

<TR>
<TD>tokenGetNftInfos</TD>
<TD><a href="#TokenGetNftInfosQuery">TokenGetNftInfosQuery</a></TD>
<TD><P>Get a list of NFTs for the token</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="QueryHeader.proto">QueryHeader.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="QueryHeader"><span class="BigBadge">Message</span>QueryHeader</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD><P>A signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD><P>The requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ResponseType"><span class="BigBadge">Enum</span>ResponseType</H3>
<P></P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD><P> Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD><P> (NOT YET SUPPORTED) Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD><P> Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD><P> (NOT YET SUPPORTED) Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Response.proto">Response.proto</H2>
<a href="#title">Top</a>
</div>
<P> A single response, which is returned from the node to the client, after the client sent the node a query. This includes all responses. </P>
<H3 id="Response"><span class="BigBadge">Message</span>Response</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>response</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>getByKey</TD>
<TD><a href="#GetByKeyResponse">GetByKeyResponse</a></TD>
<TD><P>Get all entities associated with a given key</P></TD>
</TR>

<TR>
<TD>getBySolidityID</TD>
<TD><a href="#GetBySolidityIDResponse">GetBySolidityIDResponse</a></TD>
<TD><P>Get the IDs in the format used in transactions, given the format used in Solidity</P></TD>
</TR>

<TR>
<TD>contractCallLocal</TD>
<TD><a href="#ContractCallLocalResponse">ContractCallLocalResponse</a></TD>
<TD><P>Response to call a function of a smart contract instance</P></TD>
</TR>

<TR>
<TD>contractGetBytecodeResponse</TD>
<TD><a href="#ContractGetBytecodeResponse">ContractGetBytecodeResponse</a></TD>
<TD><P>Get the bytecode for a smart contract instance</P></TD>
</TR>

<TR>
<TD>contractGetInfo</TD>
<TD><a href="#ContractGetInfoResponse">ContractGetInfoResponse</a></TD>
<TD><P>Get information about a smart contract instance</P></TD>
</TR>

<TR>
<TD>contractGetRecordsResponse</TD>
<TD><a href="#ContractGetRecordsResponse">ContractGetRecordsResponse</a></TD>
<TD><P>Get all existing records for a smart contract instance</P></TD>
</TR>

<TR>
<TD>cryptogetAccountBalance</TD>
<TD><a href="#CryptoGetAccountBalanceResponse">CryptoGetAccountBalanceResponse</a></TD>
<TD><P>Get the current balance in a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>cryptoGetAccountRecords</TD>
<TD><a href="#CryptoGetAccountRecordsResponse">CryptoGetAccountRecordsResponse</a></TD>
<TD><P>Get all the records that currently exist for transactions involving an account</P></TD>
</TR>

<TR>
<TD>cryptoGetInfo</TD>
<TD><a href="#CryptoGetInfoResponse">CryptoGetInfoResponse</a></TD>
<TD><P>Get all information about an account</P></TD>
</TR>

<TR>
<TD>cryptoGetLiveHash</TD>
<TD><a href="#CryptoGetLiveHashResponse">CryptoGetLiveHashResponse</a></TD>
<TD><P>Contains a livehash associated to an account</P></TD>
</TR>

<TR>
<TD>cryptoGetProxyStakers</TD>
<TD><a href="#CryptoGetStakersResponse">CryptoGetStakersResponse</a></TD>
<TD><P>Get all the accounts that proxy stake to a given account, and how much they proxy stake</P></TD>
</TR>

<TR>
<TD>fileGetContents</TD>
<TD><a href="#FileGetContentsResponse">FileGetContentsResponse</a></TD>
<TD><P>Get the contents of a file (the bytes stored in it)</P></TD>
</TR>

<TR>
<TD>fileGetInfo</TD>
<TD><a href="#FileGetInfoResponse">FileGetInfoResponse</a></TD>
<TD><P>Get information about a file, such as its expiration date</P></TD>
</TR>

<TR>
<TD>transactionGetReceipt</TD>
<TD><a href="#TransactionGetReceiptResponse">TransactionGetReceiptResponse</a></TD>
<TD><P>Get a receipt for a transaction</P></TD>
</TR>

<TR>
<TD>transactionGetRecord</TD>
<TD><a href="#TransactionGetRecordResponse">TransactionGetRecordResponse</a></TD>
<TD><P>Get a record for a transaction</P></TD>
</TR>

<TR>
<TD>transactionGetFastRecord</TD>
<TD><a href="#TransactionGetFastRecordResponse">TransactionGetFastRecordResponse</a></TD>
<TD><P>Get a record for a transaction (lasts 180 seconds)</P></TD>
</TR>

<TR>
<TD>consensusGetTopicInfo</TD>
<TD><a href="#ConsensusGetTopicInfoResponse">ConsensusGetTopicInfoResponse</a></TD>
<TD><P>Parameters of and state of a consensus topic..</P></TD>
</TR>

<TR>
<TD>networkGetVersionInfo</TD>
<TD><a href="#NetworkGetVersionInfoResponse">NetworkGetVersionInfoResponse</a></TD>
<TD><P>Semantic versions of Hedera Services and HAPI proto</P></TD>
</TR>

<TR>
<TD>tokenGetInfo</TD>
<TD><a href="#TokenGetInfoResponse">TokenGetInfoResponse</a></TD>
<TD><P>Get all information about a token</P></TD>
</TR>

<TR>
<TD>scheduleGetInfo</TD>
<TD><a href="#ScheduleGetInfoResponse">ScheduleGetInfoResponse</a></TD>
<TD><P>Get all information about a schedule entity</P></TD>
</TR>

<TR>
<TD>tokenGetAccountNftInfo</TD>
<TD><a href="#TokenGetAccountNftInfoResponse">TokenGetAccountNftInfoResponse</a></TD>
<TD><P>A list of the NFTs associated with the account</P></TD>
</TR>

<TR>
<TD>tokenGetNftInfo</TD>
<TD><a href="#TokenGetNftInfoResponse">TokenGetNftInfoResponse</a></TD>
<TD><P>All information about an NFT</P></TD>
</TR>

<TR>
<TD>tokenGetNftInfos</TD>
<TD><a href="#TokenGetNftInfosResponse">TokenGetNftInfosResponse</a></TD>
<TD><P>A list of the NFTs for the token</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ResponseCode.proto">ResponseCode.proto</H2>
<a href="#title">Top</a>
</div>
<P>-<BR>‌<BR>Hedera Network Services Protobuf<BR>​<BR>Copyright (C) 2018 - 2021 Hedera Hashgraph, LLC<BR>​<BR>Licensed under the Apache License, Version 2.0 (the "License");<BR>you may not use this file except in compliance with the License.<BR>You may obtain a copy of the License at<BR>http:www.apache.org/licenses/LICENSE-2.0<BR>Unless required by applicable law or agreed to in writing, software<BR>distributed under the License is distributed on an "AS IS" BASIS,<BR>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<BR>See the License for the specific language governing permissions and<BR>limitations under the License.<BR>‍</P>
<H3 id="ResponseCodeEnum"><span class="BigBadge">Enum</span>ResponseCodeEnum</H3>
<P></P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD><P>The transaction passed the precheck validations.</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD><P>For any error not handled by specific error codes listed below.</P></TD>
</TR>

<TR>
<TD>PAYER_ACCOUNT_NOT_FOUND</TD>
<TD><P>Payer account does not exist.</P></TD>
</TR>

<TR>
<TD>INVALID_NODE_ACCOUNT</TD>
<TD><P>Node Account provided does not match the node account of the node the transaction was submitted to.</P></TD>
</TR>

<TR>
<TD>TRANSACTION_EXPIRED</TD>
<TD><P>Pre-Check error when TransactionValidStart + transactionValidDuration is less than current consensus time.</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION_START</TD>
<TD><P>Transaction start time is greater than current consensus time</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION_DURATION</TD>
<TD><P>valid transaction duration is a positive non zero number that does not exceed 120 seconds</P></TD>
</TR>

<TR>
<TD>INVALID_SIGNATURE</TD>
<TD><P>The transaction signature is not valid</P></TD>
</TR>

<TR>
<TD>MEMO_TOO_LONG</TD>
<TD><P>Transaction memo size exceeded 100 bytes</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_TX_FEE</TD>
<TD><P>The fee provided in the transaction is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_PAYER_BALANCE</TD>
<TD><P>The payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE_TRANSACTION</TD>
<TD><P>This transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD><P>The API is not currently supported</P></TD>
</TR>

<TR>
<TD>INVALID_FILE_ID</TD>
<TD><P>The file id is invalid or does not exist</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT_ID</TD>
<TD><P>The account id is invalid or does not exist</P></TD>
</TR>

<TR>
<TD>INVALID_CONTRACT_ID</TD>
<TD><P>The contract id is invalid or does not exist</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION_ID</TD>
<TD><P>Transaction id is not valid</P></TD>
</TR>

<TR>
<TD>RECEIPT_NOT_FOUND</TD>
<TD><P>Receipt for given transaction id does not exist</P></TD>
</TR>

<TR>
<TD>RECORD_NOT_FOUND</TD>
<TD><P>Record for given transaction id does not exist</P></TD>
</TR>

<TR>
<TD>INVALID_SOLIDITY_ID</TD>
<TD><P>The solidity id is invalid or entity with this solidity id does not exist</P></TD>
</TR>

<TR>
<TD>UNKNOWN</TD>
<TD><P>The responding node has submitted the transaction to the network. Its final status is still unknown.</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD><P>The transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD><P>There was a system error and the transaction failed because of invalid request parameters.</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD><P>There was a system error while performing fee calculation, reserved for future.</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD><P>There was a system error while performing balance checks, reserved for future.</P></TD>
</TR>

<TR>
<TD>KEY_REQUIRED</TD>
<TD><P>Key not provided in the transaction body</P></TD>
</TR>

<TR>
<TD>BAD_ENCODING</TD>
<TD><P>Unsupported algorithm/encoding used for keys in the transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_ACCOUNT_BALANCE</TD>
<TD><P>When the account balance is not sufficient for the transfer</P></TD>
</TR>

<TR>
<TD>INVALID_SOLIDITY_ADDRESS</TD>
<TD><P>During an update transaction when the system is not able to find the Users Solidity address</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_GAS</TD>
<TD><P>Not enough gas was supplied to execute transaction</P></TD>
</TR>

<TR>
<TD>CONTRACT_SIZE_LIMIT_EXCEEDED</TD>
<TD><P>contract byte code size is over the limit</P></TD>
</TR>

<TR>
<TD>LOCAL_CALL_MODIFICATION_EXCEPTION</TD>
<TD><P>local execution (query) is requested for a function which changes state</P></TD>
</TR>

<TR>
<TD>CONTRACT_REVERT_EXECUTED</TD>
<TD><P>Contract REVERT OPCODE executed</P></TD>
</TR>

<TR>
<TD>CONTRACT_EXECUTION_EXCEPTION</TD>
<TD><P>For any contract execution related error not handled by specific error codes listed above.</P></TD>
</TR>

<TR>
<TD>INVALID_RECEIVING_NODE_ACCOUNT</TD>
<TD><P>In Query validation, account with +ve(amount) value should be Receiving node account, the receiver account should be only one account in the list</P></TD>
</TR>

<TR>
<TD>MISSING_QUERY_HEADER</TD>
<TD><P>Header is missing in Query request</P></TD>
</TR>

<TR>
<TD>ACCOUNT_UPDATE_FAILED</TD>
<TD><P>The update of the account failed</P></TD>
</TR>

<TR>
<TD>INVALID_KEY_ENCODING</TD>
<TD><P>Provided key encoding was not supported by the system</P></TD>
</TR>

<TR>
<TD>NULL_SOLIDITY_ADDRESS</TD>
<TD><P>null solidity address</P></TD>
</TR>

<TR>
<TD>CONTRACT_UPDATE_FAILED</TD>
<TD><P>update of the contract failed</P></TD>
</TR>

<TR>
<TD>INVALID_QUERY_HEADER</TD>
<TD><P>the query header is invalid</P></TD>
</TR>

<TR>
<TD>INVALID_FEE_SUBMITTED</TD>
<TD><P>Invalid fee submitted</P></TD>
</TR>

<TR>
<TD>INVALID_PAYER_SIGNATURE</TD>
<TD><P>Payer signature is invalid</P></TD>
</TR>

<TR>
<TD>KEY_NOT_PROVIDED</TD>
<TD><P>The keys were not provided in the request.</P></TD>
</TR>

<TR>
<TD>INVALID_EXPIRATION_TIME</TD>
<TD><P>Expiration time provided in the transaction was invalid.</P></TD>
</TR>

<TR>
<TD>NO_WACL_KEY</TD>
<TD><P>WriteAccess Control Keys are not provided for the file</P></TD>
</TR>

<TR>
<TD>FILE_CONTENT_EMPTY</TD>
<TD><P>The contents of file are provided as empty.</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT_AMOUNTS</TD>
<TD><P>The crypto transfer credit and debit do not sum equal to 0</P></TD>
</TR>

<TR>
<TD>EMPTY_TRANSACTION_BODY</TD>
<TD><P>Transaction body provided is empty</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION_BODY</TD>
<TD><P>Invalid transaction body provided</P></TD>
</TR>

<TR>
<TD>INVALID_SIGNATURE_TYPE_MISMATCHING_KEY</TD>
<TD><P>the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)</P></TD>
</TR>

<TR>
<TD>INVALID_SIGNATURE_COUNT_MISMATCHING_KEY</TD>
<TD><P>the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList, or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding signatureList should also have 3 base signatures.</P></TD>
</TR>

<TR>
<TD>EMPTY_LIVE_HASH_BODY</TD>
<TD><P>the livehash body is empty</P></TD>
</TR>

<TR>
<TD>EMPTY_LIVE_HASH</TD>
<TD><P>the livehash data is missing</P></TD>
</TR>

<TR>
<TD>EMPTY_LIVE_HASH_KEYS</TD>
<TD><P>the keys for a livehash are missing</P></TD>
</TR>

<TR>
<TD>INVALID_LIVE_HASH_SIZE</TD>
<TD><P>the livehash data is not the output of a SHA-384 digest</P></TD>
</TR>

<TR>
<TD>EMPTY_QUERY_BODY</TD>
<TD><P>the query body is empty</P></TD>
</TR>

<TR>
<TD>EMPTY_LIVE_HASH_QUERY</TD>
<TD><P>the crypto livehash query is empty</P></TD>
</TR>

<TR>
<TD>LIVE_HASH_NOT_FOUND</TD>
<TD><P>the livehash is not present</P></TD>
</TR>

<TR>
<TD>ACCOUNT_ID_DOES_NOT_EXIST</TD>
<TD><P>the account id passed has not yet been created.</P></TD>
</TR>

<TR>
<TD>LIVE_HASH_ALREADY_EXISTS</TD>
<TD><P>the livehash already exists for a given account</P></TD>
</TR>

<TR>
<TD>INVALID_FILE_WACL</TD>
<TD><P>File WACL keys are invalid</P></TD>
</TR>

<TR>
<TD>SERIALIZATION_FAILED</TD>
<TD><P>Serialization failure</P></TD>
</TR>

<TR>
<TD>TRANSACTION_OVERSIZE</TD>
<TD><P>The size of the Transaction is greater than transactionMaxBytes</P></TD>
</TR>

<TR>
<TD>TRANSACTION_TOO_MANY_LAYERS</TD>
<TD><P>The Transaction has more than 50 levels</P></TD>
</TR>

<TR>
<TD>CONTRACT_DELETED</TD>
<TD><P>Contract is marked as deleted</P></TD>
</TR>

<TR>
<TD>PLATFORM_NOT_ACTIVE</TD>
<TD><P>the platform node is either disconnected or lagging behind.</P></TD>
</TR>

<TR>
<TD>KEY_PREFIX_MISMATCH</TD>
<TD><P>one public key matches more than one prefixes on the signature map</P></TD>
</TR>

<TR>
<TD>PLATFORM_TRANSACTION_NOT_CREATED</TD>
<TD><P>transaction not created by platform due to large backlog</P></TD>
</TR>

<TR>
<TD>INVALID_RENEWAL_PERIOD</TD>
<TD><P>auto renewal period is not a positive number of seconds</P></TD>
</TR>

<TR>
<TD>INVALID_PAYER_ACCOUNT_ID</TD>
<TD><P>the response code when a smart contract id is passed for a crypto API request</P></TD>
</TR>

<TR>
<TD>ACCOUNT_DELETED</TD>
<TD><P>the account has been marked as deleted</P></TD>
</TR>

<TR>
<TD>FILE_DELETED</TD>
<TD><P>the file has been marked as deleted</P></TD>
</TR>

<TR>
<TD>ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS</TD>
<TD><P>same accounts repeated in the transfer account list</P></TD>
</TR>

<TR>
<TD>SETTING_NEGATIVE_ACCOUNT_BALANCE</TD>
<TD><P>attempting to set negative balance value for crypto account</P></TD>
</TR>

<TR>
<TD>OBTAINER_REQUIRED</TD>
<TD><P>when deleting smart contract that has crypto balance either transfer account or transfer smart contract is required</P></TD>
</TR>

<TR>
<TD>OBTAINER_SAME_CONTRACT_ID</TD>
<TD><P>when deleting smart contract that has crypto balance you can not use the same contract id as transferContractId as the one being deleted</P></TD>
</TR>

<TR>
<TD>OBTAINER_DOES_NOT_EXIST</TD>
<TD><P>transferAccountId or transferContractId specified for contract delete does not exist</P></TD>
</TR>

<TR>
<TD>MODIFYING_IMMUTABLE_CONTRACT</TD>
<TD><P>attempting to modify (update or delete a immutable smart contract, i.e. one created without a admin key)</P></TD>
</TR>

<TR>
<TD>FILE_SYSTEM_EXCEPTION</TD>
<TD><P>Unexpected exception thrown by file system functions</P></TD>
</TR>

<TR>
<TD>AUTORENEW_DURATION_NOT_IN_RANGE</TD>
<TD><P>the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]</P></TD>
</TR>

<TR>
<TD>ERROR_DECODING_BYTESTRING</TD>
<TD><P>Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex string.</P></TD>
</TR>

<TR>
<TD>CONTRACT_FILE_EMPTY</TD>
<TD><P>File to create a smart contract was of length zero</P></TD>
</TR>

<TR>
<TD>CONTRACT_BYTECODE_EMPTY</TD>
<TD><P>Bytecode for smart contract is of length zero</P></TD>
</TR>

<TR>
<TD>INVALID_INITIAL_BALANCE</TD>
<TD><P>Attempt to set negative initial balance</P></TD>
</TR>

<TR>
<TD>INVALID_RECEIVE_RECORD_THRESHOLD</TD>
<TD><P>[Deprecated]. attempt to set negative receive record threshold</P></TD>
</TR>

<TR>
<TD>INVALID_SEND_RECORD_THRESHOLD</TD>
<TD><P>[Deprecated]. attempt to set negative send record threshold</P></TD>
</TR>

<TR>
<TD>ACCOUNT_IS_NOT_GENESIS_ACCOUNT</TD>
<TD><P>Special Account Operations should be performed by only Genesis account, return this code if it is not Genesis Account</P></TD>
</TR>

<TR>
<TD>PAYER_ACCOUNT_UNAUTHORIZED</TD>
<TD><P>The fee payer account doesn't have permission to submit such Transaction</P></TD>
</TR>

<TR>
<TD>INVALID_FREEZE_TRANSACTION_BODY</TD>
<TD><P>FreezeTransactionBody is invalid</P></TD>
</TR>

<TR>
<TD>FREEZE_TRANSACTION_BODY_NOT_FOUND</TD>
<TD><P>FreezeTransactionBody does not exist</P></TD>
</TR>

<TR>
<TD>TRANSFER_LIST_SIZE_LIMIT_EXCEEDED</TD>
<TD><P>Exceeded the number of accounts (both from and to) allowed for crypto transfer list</P></TD>
</TR>

<TR>
<TD>RESULT_SIZE_LIMIT_EXCEEDED</TD>
<TD><P>Smart contract result size greater than specified maxResultSize</P></TD>
</TR>

<TR>
<TD>NOT_SPECIAL_ACCOUNT</TD>
<TD><P>The payer account is not a special account(account 0.0.55)</P></TD>
</TR>

<TR>
<TD>CONTRACT_NEGATIVE_GAS</TD>
<TD><P>Negative gas was offered in smart contract call</P></TD>
</TR>

<TR>
<TD>CONTRACT_NEGATIVE_VALUE</TD>
<TD><P>Negative value / initial balance was specified in a smart contract call / create</P></TD>
</TR>

<TR>
<TD>INVALID_FEE_FILE</TD>
<TD><P>Failed to update fee file</P></TD>
</TR>

<TR>
<TD>INVALID_EXCHANGE_RATE_FILE</TD>
<TD><P>Failed to update exchange rate file</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_LOCAL_CALL_GAS</TD>
<TD><P>Payment tendered for contract local call cannot cover both the fee and the gas</P></TD>
</TR>

<TR>
<TD>ENTITY_NOT_ALLOWED_TO_DELETE</TD>
<TD><P>Entities with Entity ID below 1000 are not allowed to be deleted</P></TD>
</TR>

<TR>
<TD>AUTHORIZATION_FAILED</TD>
<TD><P>Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2) account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account A/c 0.0.50 - Update all Network Function accounts & perform all the Network Functions listed below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102), ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate (0.0.112).</P></TD>
</TR>

<TR>
<TD>FILE_UPLOADED_PROTO_INVALID</TD>
<TD><P>Fee Schedule Proto uploaded but not valid (append or update is required)</P></TD>
</TR>

<TR>
<TD>FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK</TD>
<TD><P>Fee Schedule Proto uploaded but not valid (append or update is required)</P></TD>
</TR>

<TR>
<TD>FEE_SCHEDULE_FILE_PART_UPLOADED</TD>
<TD><P>Fee Schedule Proto File Part uploaded</P></TD>
</TR>

<TR>
<TD>EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED</TD>
<TD><P>The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage</P></TD>
</TR>

<TR>
<TD>MAX_CONTRACT_STORAGE_EXCEEDED</TD>
<TD><P>Contract permanent storage exceeded the currently allowable limit</P></TD>
</TR>

<TR>
<TD>TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT</TD>
<TD><P>Transfer Account should not be same as Account to be deleted</P></TD>
</TR>

<TR>
<TD>TOTAL_LEDGER_BALANCE_INVALID</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>EXPIRATION_REDUCTION_NOT_ALLOWED</TD>
<TD><P>The expiration date/time on a smart contract may not be reduced</P></TD>
</TR>

<TR>
<TD>MAX_GAS_LIMIT_EXCEEDED</TD>
<TD><P>Gas exceeded currently allowable gas limit per transaction</P></TD>
</TR>

<TR>
<TD>MAX_FILE_SIZE_EXCEEDED</TD>
<TD><P>File size exceeded the currently allowable limit</P></TD>
</TR>

<TR>
<TD>INVALID_TOPIC_ID</TD>
<TD><P>The Topic ID specified is not in the system.</P></TD>
</TR>

<TR>
<TD>INVALID_ADMIN_KEY</TD>
<TD><P>A provided admin key was invalid.</P></TD>
</TR>

<TR>
<TD>INVALID_SUBMIT_KEY</TD>
<TD><P>A provided submit key was invalid.</P></TD>
</TR>

<TR>
<TD>UNAUTHORIZED</TD>
<TD><P>An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).</P></TD>
</TR>

<TR>
<TD>INVALID_TOPIC_MESSAGE</TD>
<TD><P>A ConsensusService message is empty.</P></TD>
</TR>

<TR>
<TD>INVALID_AUTORENEW_ACCOUNT</TD>
<TD><P>The autoRenewAccount specified is not a valid, active account.</P></TD>
</TR>

<TR>
<TD>AUTORENEW_ACCOUNT_NOT_ALLOWED</TD>
<TD><P>An adminKey was not specified on the topic, so there must not be an autoRenewAccount.</P></TD>
</TR>

<TR>
<TD>TOPIC_EXPIRED</TD>
<TD><P> The topic has expired, was not automatically renewed, and is in a 7 day grace period before the topic will be<BR>deleted unrecoverably. This error response code will not be returned until autoRenew functionality is supported<BR>by HAPI.</P></TD>
</TR>

<TR>
<TD>INVALID_CHUNK_NUMBER</TD>
<TD><P>chunk number must be from 1 to total (chunks) inclusive.</P></TD>
</TR>

<TR>
<TD>INVALID_CHUNK_TRANSACTION_ID</TD>
<TD><P>For every chunk, the payer account that is part of initialTransactionID must match the Payer Account of this transaction. The entire initialTransactionID should match the transactionID of the first chunk, but this is not checked or enforced by Hedera except when the chunk number is 1.</P></TD>
</TR>

<TR>
<TD>ACCOUNT_FROZEN_FOR_TOKEN</TD>
<TD><P>Account is frozen and cannot transact with the token</P></TD>
</TR>

<TR>
<TD>TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED</TD>
<TD><P>An involved account already has more than <tt>tokens.maxPerAccount</tt> associations with non-deleted tokens.</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_ID</TD>
<TD><P>The token is invalid or does not exist</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_DECIMALS</TD>
<TD><P>Invalid token decimals</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_INITIAL_SUPPLY</TD>
<TD><P>Invalid token initial supply</P></TD>
</TR>

<TR>
<TD>INVALID_TREASURY_ACCOUNT_FOR_TOKEN</TD>
<TD><P>Treasury Account does not exist or is deleted</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_SYMBOL</TD>
<TD><P>Token Symbol is not UTF-8 capitalized alphabetical string</P></TD>
</TR>

<TR>
<TD>TOKEN_HAS_NO_FREEZE_KEY</TD>
<TD><P>Freeze key is not set on token</P></TD>
</TR>

<TR>
<TD>TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN</TD>
<TD><P>Amounts in transfer list are not net zero</P></TD>
</TR>

<TR>
<TD>MISSING_TOKEN_SYMBOL</TD>
<TD><P>A token symbol was not provided</P></TD>
</TR>

<TR>
<TD>TOKEN_SYMBOL_TOO_LONG</TD>
<TD><P>The provided token symbol was too long</P></TD>
</TR>

<TR>
<TD>ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN</TD>
<TD><P>KYC must be granted and account does not have KYC granted</P></TD>
</TR>

<TR>
<TD>TOKEN_HAS_NO_KYC_KEY</TD>
<TD><P>KYC key is not set on token</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_TOKEN_BALANCE</TD>
<TD><P>Token balance is not sufficient for the transaction</P></TD>
</TR>

<TR>
<TD>TOKEN_WAS_DELETED</TD>
<TD><P>Token transactions cannot be executed on deleted token</P></TD>
</TR>

<TR>
<TD>TOKEN_HAS_NO_SUPPLY_KEY</TD>
<TD><P>Supply key is not set on token</P></TD>
</TR>

<TR>
<TD>TOKEN_HAS_NO_WIPE_KEY</TD>
<TD><P>Wipe key is not set on token</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_MINT_AMOUNT</TD>
<TD><P>The requested token mint amount would cause an invalid total supply</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_BURN_AMOUNT</TD>
<TD><P>The requested token burn amount would cause an invalid total supply</P></TD>
</TR>

<TR>
<TD>TOKEN_NOT_ASSOCIATED_TO_ACCOUNT</TD>
<TD><P>A required token-account relationship is missing</P></TD>
</TR>

<TR>
<TD>CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT</TD>
<TD><P>The target of a wipe operation was the token treasury account</P></TD>
</TR>

<TR>
<TD>INVALID_KYC_KEY</TD>
<TD><P>The provided KYC key was invalid.</P></TD>
</TR>

<TR>
<TD>INVALID_WIPE_KEY</TD>
<TD><P>The provided wipe key was invalid.</P></TD>
</TR>

<TR>
<TD>INVALID_FREEZE_KEY</TD>
<TD><P>The provided freeze key was invalid.</P></TD>
</TR>

<TR>
<TD>INVALID_SUPPLY_KEY</TD>
<TD><P>The provided supply key was invalid.</P></TD>
</TR>

<TR>
<TD>MISSING_TOKEN_NAME</TD>
<TD><P>Token Name is not provided</P></TD>
</TR>

<TR>
<TD>TOKEN_NAME_TOO_LONG</TD>
<TD><P>Token Name is too long</P></TD>
</TR>

<TR>
<TD>INVALID_WIPING_AMOUNT</TD>
<TD><P>The provided wipe amount must not be negative, zero or bigger than the token holder balance</P></TD>
</TR>

<TR>
<TD>TOKEN_IS_IMMUTABLE</TD>
<TD><P>Token does not have Admin key set, thus update/delete transactions cannot be performed</P></TD>
</TR>

<TR>
<TD>TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT</TD>
<TD><P>An <tt>associateToken</tt> operation specified a token already associated to the account</P></TD>
</TR>

<TR>
<TD>TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES</TD>
<TD><P>An attempted operation is invalid until all token balances for the target account are zero</P></TD>
</TR>

<TR>
<TD>ACCOUNT_IS_TREASURY</TD>
<TD><P>An attempted operation is invalid because the account is a treasury</P></TD>
</TR>

<TR>
<TD>TOKEN_ID_REPEATED_IN_TOKEN_LIST</TD>
<TD><P>Same TokenIDs present in the token list</P></TD>
</TR>

<TR>
<TD>TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED</TD>
<TD><P>Exceeded the number of token transfers (both from and to) allowed for token transfer list</P></TD>
</TR>

<TR>
<TD>EMPTY_TOKEN_TRANSFER_BODY</TD>
<TD><P>TokenTransfersTransactionBody has no TokenTransferList</P></TD>
</TR>

<TR>
<TD>EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS</TD>
<TD><P>TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts</P></TD>
</TR>

<TR>
<TD>INVALID_SCHEDULE_ID</TD>
<TD><P>The Scheduled entity does not exist; or has now expired, been deleted, or been executed</P></TD>
</TR>

<TR>
<TD>SCHEDULE_IS_IMMUTABLE</TD>
<TD><P>The Scheduled entity cannot be modified. Admin key not set</P></TD>
</TR>

<TR>
<TD>INVALID_SCHEDULE_PAYER_ID</TD>
<TD><P>The provided Scheduled Payer does not exist</P></TD>
</TR>

<TR>
<TD>INVALID_SCHEDULE_ACCOUNT_ID</TD>
<TD><P>The Schedule Create Transaction TransactionID account does not exist</P></TD>
</TR>

<TR>
<TD>NO_NEW_VALID_SIGNATURES</TD>
<TD><P>The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction</P></TD>
</TR>

<TR>
<TD>UNRESOLVABLE_REQUIRED_SIGNERS</TD>
<TD><P>The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted</P></TD>
</TR>

<TR>
<TD>SCHEDULED_TRANSACTION_NOT_IN_WHITELIST</TD>
<TD><P>Only whitelisted transaction types may be scheduled</P></TD>
</TR>

<TR>
<TD>SOME_SIGNATURES_WERE_INVALID</TD>
<TD><P>At least one of the signatures in the provided sig map did not represent a valid signature for any required signer</P></TD>
</TR>

<TR>
<TD>TRANSACTION_ID_FIELD_NOT_ALLOWED</TD>
<TD><P>The scheduled field in the TransactionID may not be set to true</P></TD>
</TR>

<TR>
<TD>IDENTICAL_SCHEDULE_ALREADY_CREATED</TD>
<TD><P>A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)</P></TD>
</TR>

<TR>
<TD>INVALID_ZERO_BYTE_IN_STRING</TD>
<TD><P>A string field in the transaction has a UTF-8 encoding with the prohibited zero byte</P></TD>
</TR>

<TR>
<TD>SCHEDULE_ALREADY_DELETED</TD>
<TD><P>A schedule being signed or deleted has already been deleted</P></TD>
</TR>

<TR>
<TD>SCHEDULE_ALREADY_EXECUTED</TD>
<TD><P>A schedule being signed or deleted has already been executed</P></TD>
</TR>

<TR>
<TD>MESSAGE_SIZE_TOO_LARGE</TD>
<TD><P>ConsensusSubmitMessage request's message size is larger than allowed.</P></TD>
</TR>

<TR>
<TD>OPERATION_REPEATED_IN_BUCKET_GROUPS</TD>
<TD><P>An operation was assigned to more than one throttle group in a given bucket</P></TD>
</TR>

<TR>
<TD>BUCKET_CAPACITY_OVERFLOW</TD>
<TD><P>The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type</P></TD>
</TR>

<TR>
<TD>NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION</TD>
<TD><P>Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased</P></TD>
</TR>

<TR>
<TD>BUCKET_HAS_NO_THROTTLE_GROUPS</TD>
<TD><P>A bucket was defined without any throttle groups</P></TD>
</TR>

<TR>
<TD>THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC</TD>
<TD><P>A throttle group was granted zero opsPerSec</P></TD>
</TR>

<TR>
<TD>SUCCESS_BUT_MISSING_EXPECTED_OPERATION</TD>
<TD><P>The throttle definitions file was updated, but some supported operations were not assigned a bucket</P></TD>
</TR>

<TR>
<TD>UNPARSEABLE_THROTTLE_DEFINITIONS</TD>
<TD><P>The new contents for the throttle definitions system file were not valid protobuf</P></TD>
</TR>

<TR>
<TD>INVALID_THROTTLE_DEFINITIONS</TD>
<TD><P>The new throttle definitions system file were invalid, and no more specific error could be divined</P></TD>
</TR>

<TR>
<TD>ACCOUNT_EXPIRED_AND_PENDING_REMOVAL</TD>
<TD><P>The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_MAX_SUPPLY</TD>
<TD><P>Invalid token max supply</P></TD>
</TR>

<TR>
<TD>INVALID_TOKEN_NFT_SERIAL_NUMBER</TD>
<TD><P>Invalid token nft serial number</P></TD>
</TR>

<TR>
<TD>INVALID_NFT_ID</TD>
<TD><P>Invalid nft id</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ResponseHeader.proto">ResponseHeader.proto</H2>
<a href="#title">Top</a>
</div>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didn't ask for the cost or stateProof. </P>
<H3 id="ResponseHeader"><span class="BigBadge">Message</span>ResponseHeader</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#ResponseCodeEnum">ResponseCodeEnum</a></TD>
<TD><P>Result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD><P>The requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD><P>The fee that would be charged to get the requested information (if a cost was requested). Note: This cost only includes the query fee and does not include the transfer fee(which is required to execute the transfer transaction to debit the payer account and credit the node account with query fee)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD><P>The state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="SchedulableTransactionBody.proto">SchedulableTransactionBody.proto</H2>
<a href="#title">Top</a>
</div>
<P> A schedulable transaction. Note that the global/dynamic system property</P>
<H3 id="SchedulableTransactionBody"><span class="BigBadge">Message</span>SchedulableTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD><P>The maximum transaction fee the client is willing to pay</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>A memo to include the execution record; the UTF-8 encoding may be up to 100 bytes and must not include the zero byte</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD><P>Calls a function of a contract instance</P></TD>
</TR>

<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD><P>Creates a contract instance</P></TD>
</TR>

<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD><P>Updates a contract</P></TD>
</TR>

<TR>
<TD>contractDeleteInstance</TD>
<TD><a href="#ContractDeleteTransactionBody">ContractDeleteTransactionBody</a></TD>
<TD><P>Delete contract and transfer remaining balance into specified account</P></TD>
</TR>

<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD><P>Create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD><P>Delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD><P>Transfer amount between accounts</P></TD>
</TR>

<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD><P>Modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD><P>Add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD><P>Create a new file</P></TD>
</TR>

<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD><P>Delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD><P>Modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>systemDelete</TD>
<TD><a href="#SystemDeleteTransactionBody">SystemDeleteTransactionBody</a></TD>
<TD><P>Hedera administrative deletion of a file or smart contract</P></TD>
</TR>

<TR>
<TD>systemUndelete</TD>
<TD><a href="#SystemUndeleteTransactionBody">SystemUndeleteTransactionBody</a></TD>
<TD><P>To undelete an entity deleted by SystemDelete</P></TD>
</TR>

<TR>
<TD>freeze</TD>
<TD><a href="#FreezeTransactionBody">FreezeTransactionBody</a></TD>
<TD><P>Freeze the nodes</P></TD>
</TR>

<TR>
<TD>consensusCreateTopic</TD>
<TD><a href="#ConsensusCreateTopicTransactionBody">ConsensusCreateTopicTransactionBody</a></TD>
<TD><P>Creates a topic</P></TD>
</TR>

<TR>
<TD>consensusUpdateTopic</TD>
<TD><a href="#ConsensusUpdateTopicTransactionBody">ConsensusUpdateTopicTransactionBody</a></TD>
<TD><P>Updates a topic</P></TD>
</TR>

<TR>
<TD>consensusDeleteTopic</TD>
<TD><a href="#ConsensusDeleteTopicTransactionBody">ConsensusDeleteTopicTransactionBody</a></TD>
<TD><P>Deletes a topic</P></TD>
</TR>

<TR>
<TD>consensusSubmitMessage</TD>
<TD><a href="#ConsensusSubmitMessageTransactionBody">ConsensusSubmitMessageTransactionBody</a></TD>
<TD><P>Submits message to a topic</P></TD>
</TR>

<TR>
<TD>tokenCreation</TD>
<TD><a href="#TokenCreateTransactionBody">TokenCreateTransactionBody</a></TD>
<TD><P>Creates a token instance</P></TD>
</TR>

<TR>
<TD>tokenFreeze</TD>
<TD><a href="#TokenFreezeAccountTransactionBody">TokenFreezeAccountTransactionBody</a></TD>
<TD><P>Freezes account not to be able to transact with a token</P></TD>
</TR>

<TR>
<TD>tokenUnfreeze</TD>
<TD><a href="#TokenUnfreezeAccountTransactionBody">TokenUnfreezeAccountTransactionBody</a></TD>
<TD><P>Unfreezes account for a token</P></TD>
</TR>

<TR>
<TD>tokenGrantKyc</TD>
<TD><a href="#TokenGrantKycTransactionBody">TokenGrantKycTransactionBody</a></TD>
<TD><P>Grants KYC to an account for a token</P></TD>
</TR>

<TR>
<TD>tokenRevokeKyc</TD>
<TD><a href="#TokenRevokeKycTransactionBody">TokenRevokeKycTransactionBody</a></TD>
<TD><P>Revokes KYC of an account for a token</P></TD>
</TR>

<TR>
<TD>tokenDeletion</TD>
<TD><a href="#TokenDeleteTransactionBody">TokenDeleteTransactionBody</a></TD>
<TD><P>Deletes a token instance</P></TD>
</TR>

<TR>
<TD>tokenUpdate</TD>
<TD><a href="#TokenUpdateTransactionBody">TokenUpdateTransactionBody</a></TD>
<TD><P>Updates a token instance</P></TD>
</TR>

<TR>
<TD>tokenMint</TD>
<TD><a href="#TokenMintTransactionBody">TokenMintTransactionBody</a></TD>
<TD><P>Mints new tokens to a token's treasury account</P></TD>
</TR>

<TR>
<TD>tokenBurn</TD>
<TD><a href="#TokenBurnTransactionBody">TokenBurnTransactionBody</a></TD>
<TD><P>Burns tokens from a token's treasury account</P></TD>
</TR>

<TR>
<TD>tokenWipe</TD>
<TD><a href="#TokenWipeAccountTransactionBody">TokenWipeAccountTransactionBody</a></TD>
<TD><P>Wipes amount of tokens from an account</P></TD>
</TR>

<TR>
<TD>tokenAssociate</TD>
<TD><a href="#TokenAssociateTransactionBody">TokenAssociateTransactionBody</a></TD>
<TD><P>Associate tokens to an account</P></TD>
</TR>

<TR>
<TD>tokenDissociate</TD>
<TD><a href="#TokenDissociateTransactionBody">TokenDissociateTransactionBody</a></TD>
<TD><P>Dissociate tokens from an account</P></TD>
</TR>

<TR>
<TD>scheduleDelete</TD>
<TD><a href="#ScheduleDeleteTransactionBody">ScheduleDeleteTransactionBody</a></TD>
<TD><P>Marks a schedule in the network's action queue as deleted, preventing it from executing</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ScheduleCreate.proto">ScheduleCreate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ScheduleCreateTransactionBody"><span class="BigBadge">Message</span>ScheduleCreateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>scheduledTransactionBody</TD>
<TD><a href="#SchedulableTransactionBody">SchedulableTransactionBody</a></TD>
<TD><P>The scheduled transaction</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>An optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the zero byte</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>An optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule</P></TD>
</TR>

<TR>
<TD>payerAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>An optional id of the account to be charged the service fee for the scheduled transaction at the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not given</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ScheduleDelete.proto">ScheduleDelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ScheduleDeleteTransactionBody"><span class="BigBadge">Message</span>ScheduleDeleteTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>scheduleID</TD>
<TD><a href="#ScheduleID">ScheduleID</a></TD>
<TD><P>The ID of the Scheduled Entity</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ScheduleGetInfo.proto">ScheduleGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ScheduleGetInfoQuery"><span class="BigBadge">Message</span>ScheduleGetInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>standard info sent from client to node including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>scheduleID</TD>
<TD><a href="#ScheduleID">ScheduleID</a></TD>
<TD><P>The id of the schedule to interrogate</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ScheduleGetInfoResponse"><span class="BigBadge">Message</span>ScheduleGetInfoResponse</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>scheduleInfo</TD>
<TD><a href="#ScheduleInfo">ScheduleInfo</a></TD>
<TD><P>The information requested about this schedule instance</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ScheduleInfo"><span class="BigBadge">Message</span>ScheduleInfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>scheduleID</TD>
<TD><a href="#ScheduleID">ScheduleID</a></TD>
<TD><P>The id of the schedule</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>deletion_time</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>If the schedule has been deleted, the consensus time when this occurred</P></TD>
</TR>

<TR>
<TD>execution_time</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>If the schedule has been executed, the consensus time when this occurred</P></TD>
</TR>

<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The time at which the schedule will expire</P></TD>
</TR>

<TR>
<TD>scheduledTransactionBody</TD>
<TD><a href="#SchedulableTransactionBody">SchedulableTransactionBody</a></TD>
<TD><P>The scheduled transaction</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The publicly visible memo of the schedule</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key used to delete the schedule from state</P></TD>
</TR>

<TR>
<TD>signers</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD><P>The Ed25519 keys the network deems to have signed the scheduled transaction</P></TD>
</TR>

<TR>
<TD>creatorAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The id of the account that created the schedule</P></TD>
</TR>

<TR>
<TD>payerAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The id of the account responsible for the service fee of the scheduled transaction</P></TD>
</TR>

<TR>
<TD>scheduledTransactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P>The transaction id that will be used in the record of the scheduled transaction (if it executes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ScheduleService.proto">ScheduleService.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ScheduleService"><span class="BigBadge">Service</span>ScheduleService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>createSchedule </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Creates a new Schedule by submitting the transaction</P></TD>
</TR>

<TR>
<TD>signSchedule </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Signs a new Schedule by submitting the transaction</P></TD>
</TR>

<TR>
<TD>deleteSchedule </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Deletes a new Schedule by submitting the transaction</P></TD>
</TR>

<TR>
<TD>getScheduleInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the metadata of a schedule entity</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ScheduleSign.proto">ScheduleSign.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ScheduleSignTransactionBody"><span class="BigBadge">Message</span>ScheduleSignTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>scheduleID</TD>
<TD><a href="#ScheduleID">ScheduleID</a></TD>
<TD><P>The id of the schedule to add signing keys to</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="SmartContractService.proto">SmartContractService.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="SmartContractService"><span class="BigBadge">Service</span>SmartContractService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>createContract </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Creates a contract</P></TD>
</TR>

<TR>
<TD>updateContract </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Updates a contract with the content</P></TD>
</TR>

<TR>
<TD>contractCallMethod </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Calls a contract</P></TD>
</TR>

<TR>
<TD>getContractInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the contract information</P></TD>
</TR>

<TR>
<TD>contractCallLocalMethod </TD><TD>Query</TD><TD>Response</TD><TD><P> Calls a smart contract to be run on a single node</P></TD>
</TR>

<TR>
<TD>ContractGetBytecode </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the byte code of a contract</P></TD>
</TR>

<TR>
<TD>getBySolidityID </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves a contract by its Solidity address</P></TD>
</TR>

<TR>
<TD>getTxRecordByContractID </TD><TD>Query</TD><TD>Response) {<TD><P> Always returns an empty record list, as contract accounts are never effective payers for transactions</P></TD>
</TR>

<TR>
<TD>option deprecated  =  true;<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="SystemDelete.proto">SystemDelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="SystemDeleteTransactionBody"><span class="BigBadge">Message</span>SystemDeleteTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file ID of the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>The contract ID instance to delete, in the format used in transactions</P></TD>
</TR>

<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD><P>The timestamp in seconds at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="SystemUndelete.proto">SystemUndelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="SystemUndeleteTransactionBody"><span class="BigBadge">Message</span>SystemUndeleteTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P>The file ID to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P>The contract ID instance to undelete, in the format used in transactions</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ThrottleDefinitions.proto">ThrottleDefinitions.proto</H2>
<a href="#title">Top</a>
</div>
<P> A set of operations which should be collectively throttled at a given milli-ops-per-second limit. </P>
<H3 id="ThrottleBucket"><span class="BigBadge">Message</span>ThrottleBucket</H3>
<P> A list of throttle groups that should all compete for the same internal bucket. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>name</TD>
<TD>string</TD>
<TD><P>A name for this bucket (primarily for use in logs)</P></TD>
</TR>

<TR>
<TD>burstPeriodMs</TD>
<TD>uint64</TD>
<TD><P>The number of milliseconds required for this bucket to drain completely when full. The product of this number and the least common multiple of the milliOpsPerSec values in this bucket must not exceed 9223372036.</P></TD>
</TR>

<TR>
<TD>throttleGroups</TD>
<TD><a href="#ThrottleGroup">ThrottleGroup</a> (repeated)</TD>
<TD><P>The throttle groups competing for this bucket</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ThrottleDefinitions"><span class="BigBadge">Message</span>ThrottleDefinitions</H3>
<P> A list of throttle buckets which, simultaneously enforced, define the system's throttling policy.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>throttleBuckets</TD>
<TD><a href="#ThrottleBucket">ThrottleBucket</a> (repeated)</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ThrottleGroup"><span class="BigBadge">Message</span>ThrottleGroup</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>operations</TD>
<TD><a href="#HederaFunctionality">HederaFunctionality</a> (repeated)</TD>
<TD><P>The operations to be throttled</P></TD>
</TR>

<TR>
<TD>milliOpsPerSec</TD>
<TD>uint64</TD>
<TD><P>The number of total operations per second across the entire network, multiplied by 1000. So, to choose 3 operations per second (which on a network of 30 nodes is a tenth of an operation per second for each node), set milliOpsPerSec = 3000. And to choose 3.6 ops per second, use milliOpsPerSec = 3600. Minimum allowed value is 1, and maximum allowed value is 9223372.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Timestamp.proto">Timestamp.proto</H2>
<a href="#title">Top</a>
</div>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<H3 id="Timestamp"><span class="BigBadge">Message</span>Timestamp</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD><P>Number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD><P>Number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TimestampSeconds"><span class="BigBadge">Message</span>TimestampSeconds</H3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD><P>Number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenAssociate.proto">TokenAssociate.proto</H2>
<a href="#title">Top</a>
</div>
<P> Associates the provided account with the provided tokens. Must be signed by the provided Account's key.</P>
<H3 id="TokenAssociateTransactionBody"><span class="BigBadge">Message</span>TokenAssociateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>account</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account to be associated with the provided tokens</P></TD>
</TR>

<TR>
<TD>tokens</TD>
<TD><a href="#TokenID">TokenID</a> (repeated)</TD>
<TD><P>The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that token type</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenBurn.proto">TokenBurn.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TokenBurnTransactionBody"><span class="BigBadge">Message</span>TokenBurnTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which to burn tokens. If token does not exist, transaction results in INVALID_TOKEN_ID</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>uint64</TD>
<TD><P>Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account. Amount must be a positive non-zero number, not bigger than the token balance of the treasury account (0; balance], represented in the lowest denomination.</P></TD>
</TR>

<TR>
<TD>serialNumbers</TD>
<TD>int64 (repeated)</TD>
<TD><P>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenCreate.proto">TokenCreate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TokenCreateTransactionBody"><span class="BigBadge">Message</span>TokenCreateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>name</TD>
<TD>string</TD>
<TD><P>The publicly visible name of the token, limited to a UTF-8 encoding of length <tt>tokens.maxSymbolUtf8Bytes</tt>.</P></TD>
</TR>

<TR>
<TD>symbol</TD>
<TD>string</TD>
<TD><P>The publicly visible token symbol, limited to a UTF-8 encoding of length <tt>tokens.maxTokenNameUtf8Bytes</tt>.</P></TD>
</TR>

<TR>
<TD>decimals</TD>
<TD>uint32</TD>
<TD><P>For tokens of type FUNGIBLE_COMMON - the number of decimal places a token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value must be 0</P></TD>
</TR>

<TR>
<TD>initialSupply</TD>
<TD>uint64</TD>
<TD><P>Specifies the initial supply of tokens to be put in circulation. The initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type the value must be 0</P></TD>
</TR>

<TR>
<TD>treasury</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account which will act as a treasury for the token. This account will receive the specified initial supply or the newly minted NFTs in the case for NON_FUNGIBLE_UNIQUE Type</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can perform update/delete operations on the token. If empty, the token can be perceived as immutable (not being able to be updated/deleted)</P></TD>
</TR>

<TR>
<TD>kycKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required, and KYC grant or revoke operations are not possible.</P></TD>
</TR>

<TR>
<TD>freezeKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can sign to freeze or unfreeze an account for token transactions. If empty, freezing is not possible</P></TD>
</TR>

<TR>
<TD>wipeKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can wipe the token balance of an account. If empty, wipe is not possible</P></TD>
</TR>

<TR>
<TD>supplyKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations</P></TD>
</TR>

<TR>
<TD>freezeDefault</TD>
<TD>bool</TD>
<TD><P>The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If true, an account must be unfrozen before it can receive the token</P></TD>
</TR>

<TR>
<TD>expiry</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The epoch second at which the token should expire; if an auto-renew account and period are specified, this is coerced to the current epoch second plus the autoRenewPeriod</P></TD>
</TR>

<TR>
<TD>autoRenewAccount</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>The interval at which the auto-renew account will be charged to extend the token's expiry</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo associated with the token (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<TR>
<TD>tokenType</TD>
<TD><a href="#TokenType">TokenType</a></TD>
<TD><P>IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON</P></TD>
</TR>

<TR>
<TD>supplyType</TD>
<TD><a href="#TokenSupplyType">TokenSupplyType</a></TD>
<TD><P>IWA compatibility. Specified the token supply type. Defaults to INFINITE</P></TD>
</TR>

<TR>
<TD>maxSupply</TD>
<TD>int64</TD>
<TD><P>IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenDelete.proto">TokenDelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TokenDeleteTransactionBody"><span class="BigBadge">Message</span>TokenDeleteTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token to be deleted. If invalid token is specified, transaction will result in INVALID_TOKEN_ID</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenDissociate.proto">TokenDissociate.proto</H2>
<a href="#title">Top</a>
</div>
<P> Dissociates the provided account with the provided tokens. Must be signed by the provided Account's key.</P>
<H3 id="TokenDissociateTransactionBody"><span class="BigBadge">Message</span>TokenDissociateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>account</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account to be dissociated with the provided tokens</P></TD>
</TR>

<TR>
<TD>tokens</TD>
<TD><a href="#TokenID">TokenID</a> (repeated)</TD>
<TD><P>The tokens to be dissociated with the provided account</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenFreezeAccount.proto">TokenFreezeAccount.proto</H2>
<a href="#title">Top</a>
</div>
<P> Freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.</P>
<H3 id="TokenFreezeAccountTransactionBody"><span class="BigBadge">Message</span>TokenFreezeAccountTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which this account will be frozen. If token does not exist, transaction results in INVALID_TOKEN_ID</P></TD>
</TR>

<TR>
<TD>account</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account to be frozen</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenGetAccountNftInfo.proto">TokenGetAccountNftInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M owned by the specified accountId.<BR>Example: If Account A owns 5 NFTs (might be of different Token Entity), having start=0 and end=5 will return all of the NFTs</P>
<H3 id="TokenGetAccountNftInfoQuery"><span class="BigBadge">Message</span>TokenGetAccountNftInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The Account for which information is requested</P></TD>
</TR>

<TR>
<TD>start</TD>
<TD>int64</TD>
<TD><P>Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the range [0; ownedNFTs-1]</P></TD>
</TR>

<TR>
<TD>end</TD>
<TD>int64</TD>
<TD><P>Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the range (start; ownedNFTs]</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenGetAccountNftInfoResponse"><span class="BigBadge">Message</span>TokenGetAccountNftInfoResponse</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>nfts</TD>
<TD><a href="#TokenNftInfo">TokenNftInfo</a> (repeated)</TD>
<TD><P>List of NFTs associated to the account</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenGetInfo.proto">TokenGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Gets information about Token instance </P>
<H3 id="TokenGetInfoQuery"><span class="BigBadge">Message</span>TokenGetInfoQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither)</P></TD>
</TR>

<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID response is returned.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenGetInfoResponse"><span class="BigBadge">Message</span>TokenGetInfoResponse</H3>
<P> Response when the client sends the node TokenGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>tokenInfo</TD>
<TD><a href="#TokenInfo">TokenInfo</a></TD>
<TD><P>The information requested about this token instance</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenInfo"><span class="BigBadge">Message</span>TokenInfo</H3>
<P> The metadata about a Token instance </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>tokenId</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>ID of the token instance</P></TD>
</TR>

<TR>
<TD>name</TD>
<TD>string</TD>
<TD><P>The name of the token. It is a string of ASCII only characters</P></TD>
</TR>

<TR>
<TD>symbol</TD>
<TD>string</TD>
<TD><P>The symbol of the token. It is a UTF-8 capitalized alphabetical string</P></TD>
</TR>

<TR>
<TD>decimals</TD>
<TD>uint32</TD>
<TD><P>The number of decimal places a token is divisible by. Always 0 for tokens of type NON_FUNGIBLE_UNIQUE</P></TD>
</TR>

<TR>
<TD>totalSupply</TD>
<TD>uint64</TD>
<TD><P>For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this token instance</P></TD>
</TR>

<TR>
<TD>treasury</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The ID of the account which is set as Treasury</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can perform update/delete operations on the token. If empty, the token can be perceived as immutable (not being able to be updated/deleted)</P></TD>
</TR>

<TR>
<TD>kycKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required, and KYC grant or revoke operations are not possible.</P></TD>
</TR>

<TR>
<TD>freezeKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible</P></TD>
</TR>

<TR>
<TD>wipeKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can wipe token balance of an account. If empty, wipe is not possible</P></TD>
</TR>

<TR>
<TD>supplyKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations</P></TD>
</TR>

<TR>
<TD>defaultFreezeStatus</TD>
<TD><a href="#TokenFreezeStatus">TokenFreezeStatus</a></TD>
<TD><P>The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false</P></TD>
</TR>

<TR>
<TD>defaultKycStatus</TD>
<TD><a href="#TokenKycStatus">TokenKycStatus</a></TD>
<TD><P>The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked</P></TD>
</TR>

<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD><P>Specifies whether the token was deleted or not</P></TD>
</TR>

<TR>
<TD>autoRenewAccount</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>The interval at which the auto-renew account will be charged to extend the token's expiry</P></TD>
</TR>

<TR>
<TD>expiry</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The epoch second at which the token will expire</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo associated with the token</P></TD>
</TR>

<TR>
<TD>tokenType</TD>
<TD><a href="#TokenType">TokenType</a></TD>
<TD><P>The token type</P></TD>
</TR>

<TR>
<TD>supplyType</TD>
<TD><a href="#TokenSupplyType">TokenSupplyType</a></TD>
<TD><P>The token supply type</P></TD>
</TR>

<TR>
<TD>maxSupply</TD>
<TD>int64</TD>
<TD><P>For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial numbers) that can be in circulation</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenGetNftInfo.proto">TokenGetNftInfo.proto</H2>
<a href="#title">Top</a>
</div>
<P> Represents an NFT on the Ledger </P>
<H3 id="NftID"><span class="BigBadge">Message</span>NftID</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>tokenID</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The (non-fungible) token of which this NFT is an instance</P></TD>
</TR>

<TR>
<TD>serialNumber</TD>
<TD>int64</TD>
<TD><P>The unique identifier of this instance</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenGetNftInfoQuery"><span class="BigBadge">Message</span>TokenGetNftInfoQuery</H3>
<P> Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on a NFT for a given TokenID (of type NON_FUNGIBLE_UNIQUE) and serial number </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>nftID</TD>
<TD><a href="#NftID">NftID</a></TD>
<TD><P>The ID of the NFT</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenGetNftInfoResponse"><span class="BigBadge">Message</span>TokenGetNftInfoResponse</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>nft</TD>
<TD><a href="#TokenNftInfo">TokenNftInfo</a></TD>
<TD><P>The information about this NFT</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenNftInfo"><span class="BigBadge">Message</span>TokenNftInfo</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nftID</TD>
<TD><a href="#NftID">NftID</a></TD>
<TD><P>The ID of the NFT</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The current owner of the NFT</P></TD>
</TR>

<TR>
<TD>creationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The effective consensus timestamp at which the NFT was minted</P></TD>
</TR>

<TR>
<TD>metadata</TD>
<TD>bytes</TD>
<TD><P>Represents the unique metadata of the NFT</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenGetNftInfos.proto">TokenGetNftInfos.proto</H2>
<a href="#title">Top</a>
</div>
<P> Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M on the list of NFTs associated with a given NON_FUNGIBLE_UNIQUE Token.<BR>Example: If there are 10 NFTs issued, having start=0 and end=5 will query for the first 5 NFTs. Querying +all 10 NFTs will require start=0 and end=10</P>
<H3 id="TokenGetNftInfosQuery"><span class="BigBadge">Message</span>TokenGetNftInfosQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>tokenID</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The ID of the token for which information is requested</P></TD>
</TR>

<TR>
<TD>start</TD>
<TD>int64</TD>
<TD><P>Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the range [0; ownedNFTs-1]</P></TD>
</TR>

<TR>
<TD>end</TD>
<TD>int64</TD>
<TD><P>Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the range (start; ownedNFTs]</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TokenGetNftInfosResponse"><span class="BigBadge">Message</span>TokenGetNftInfosResponse</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>tokenID</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The Token with type NON_FUNGIBLE that this record is for</P></TD>
</TR>

<TR>
<TD>nfts</TD>
<TD><a href="#TokenNftInfo">TokenNftInfo</a> (repeated)</TD>
<TD><P>List of NFTs associated to the specified token</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenGrantKyc.proto">TokenGrantKyc.proto</H2>
<a href="#title">Top</a>
</div>
<P> Grants KYC to the account for the given token. Must be signed by the Token's kycKey.</P>
<H3 id="TokenGrantKycTransactionBody"><span class="BigBadge">Message</span>TokenGrantKycTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which this account will be granted KYC. If token does not exist, transaction results in INVALID_TOKEN_ID</P></TD>
</TR>

<TR>
<TD>account</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account to be KYCed</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenMint.proto">TokenMint.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TokenMintTransactionBody"><span class="BigBadge">Message</span>TokenMintTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which to mint tokens. If token does not exist, transaction results in INVALID_TOKEN_ID</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>uint64</TD>
<TD><P>Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account. Amount must be a positive non-zero number represented in the lowest denomination of the token. The new supply must be lower than 2^63.</P></TD>
</TR>

<TR>
<TD>metadata</TD>
<TD>bytes (repeated)</TD>
<TD><P>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created. Maximum allowed size of each metadata is 100 bytes</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenRevokeKyc.proto">TokenRevokeKyc.proto</H2>
<a href="#title">Top</a>
</div>
<P> Revokes KYC to the account for the given token. Must be signed by the Token's kycKey.</P>
<H3 id="TokenRevokeKycTransactionBody"><span class="BigBadge">Message</span>TokenRevokeKycTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which this account will get his KYC revoked. If token does not exist, transaction results in INVALID_TOKEN_ID</P></TD>
</TR>

<TR>
<TD>account</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account to be KYC Revoked</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenService.proto">TokenService.proto</H2>
<a href="#title">Top</a>
</div>
<P> Transactions and queries for the Token Service </P>
<H3 id="TokenService"><span class="BigBadge">Service</span>TokenService</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>RPC</TD>
<TD>Request</TD>
<TD>Response</TD>
<TD>Comments</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>createToken </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Creates a new Token by submitting the transaction</P></TD>
</TR>

<TR>
<TD>updateToken </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Updates the account by submitting the transaction</P></TD>
</TR>

<TR>
<TD>mintToken </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Mints an amount of the token to the defined treasury account</P></TD>
</TR>

<TR>
<TD>burnToken </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Burns an amount of the token from the defined treasury account</P></TD>
</TR>

<TR>
<TD>deleteToken </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Deletes a Token</P></TD>
</TR>

<TR>
<TD>wipeTokenAccount </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Wipes the provided amount of tokens from the specified Account ID</P></TD>
</TR>

<TR>
<TD>freezeTokenAccount </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Freezes the transfer of tokens to or from the specified Account ID</P></TD>
</TR>

<TR>
<TD>unfreezeTokenAccount </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Unfreezes the transfer of tokens to or from the specified Account ID</P></TD>
</TR>

<TR>
<TD>grantKycToTokenAccount </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Flags the provided Account ID as having gone through KYC</P></TD>
</TR>

<TR>
<TD>revokeKycFromTokenAccount </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Removes the KYC flag of the provided Account ID</P></TD>
</TR>

<TR>
<TD>associateTokens </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Associates tokens to an account</P></TD>
</TR>

<TR>
<TD>dissociateTokens </TD><TD>Transaction</TD><TD>TransactionResponse</TD><TD><P> Dissociates tokens from an account</P></TD>
</TR>

<TR>
<TD>getTokenInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the metadata of a token</P></TD>
</TR>

<TR>
<TD>getAccountNftInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Gets info on NFTs N through M on the list of NFTs associated with a given account</P></TD>
</TR>

<TR>
<TD>getTokenNftInfo </TD><TD>Query</TD><TD>Response</TD><TD><P> Retrieves the metadata of an NFT by TokenID and serial number</P></TD>
</TR>

<TR>
<TD>getTokenNftInfos </TD><TD>Query</TD><TD>Response</TD><TD><P> Gets info on NFTs N through M on the list of NFTs associated with a given Token of type NON_FUNGIBLE</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenUnfreezeAccount.proto">TokenUnfreezeAccount.proto</H2>
<a href="#title">Top</a>
</div>
<P> Unfreezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.</P>
<H3 id="TokenUnfreezeAccountTransactionBody"><span class="BigBadge">Message</span>TokenUnfreezeAccountTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which this account will be unfrozen. If token does not exist, transaction results in INVALID_TOKEN_ID</P></TD>
</TR>

<TR>
<TD>account</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account to be unfrozen</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenUpdate.proto">TokenUpdate.proto</H2>
<a href="#title">Top</a>
</div>
<P> At consensus, updates an already created token to the given values.</P>
<H3 id="TokenUpdateTransactionBody"><span class="BigBadge">Message</span>TokenUpdateTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The Token to be updated</P></TD>
</TR>

<TR>
<TD>symbol</TD>
<TD>string</TD>
<TD><P>The new publicly visible Token symbol, limited to a UTF-8 encoding of length <tt>tokens.maxTokenNameUtf8Bytes</tt>.</P></TD>
</TR>

<TR>
<TD>name</TD>
<TD>string</TD>
<TD><P>The new publicly visible name of the Token, limited to a UTF-8 encoding of length <tt>tokens.maxSymbolUtf8Bytes</tt>.</P></TD>
</TR>

<TR>
<TD>treasury</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The new Treasury account of the Token. If the provided treasury account is not existing or deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token balance held in the previous Treasury Account is transferred to the new one.</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The new admin key of the Token. If Token is immutable, transaction will resolve to TOKEN_IS_IMMUTABlE.</P></TD>
</TR>

<TR>
<TD>kycKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The new KYC key of the Token. If Token does not have currently a KYC key, transaction will resolve to TOKEN_HAS_NO_KYC_KEY.</P></TD>
</TR>

<TR>
<TD>freezeKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The new Freeze key of the Token. If the Token does not have currently a Freeze key, transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.</P></TD>
</TR>

<TR>
<TD>wipeKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction will resolve to TOKEN_HAS_NO_WIPE_KEY.</P></TD>
</TR>

<TR>
<TD>supplyKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD><P>The new Supply key of the Token. If the Token does not have currently a Supply key, transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.</P></TD>
</TR>

<TR>
<TD>autoRenewAccount</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The new account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>The new interval at which the auto-renew account will be charged to extend the token's expiry.</P></TD>
</TR>

<TR>
<TD>expiry</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The new expiry time of the token. Expiry can be updated even if admin key is not set. If the provided expiry is earlier than the current token expiry, transaction wil resolve to INVALID_EXPIRATION_TIME</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD><a href="#google.protobuf.StringValue">google.protobuf.StringValue</a></TD>
<TD><P>If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TokenWipeAccount.proto">TokenWipeAccount.proto</H2>
<a href="#title">Top</a>
</div>
<P> Wipes the provided amount of tokens from the specified Account. Must be signed by the Token's Wipe key.</P>
<H3 id="TokenWipeAccountTransactionBody"><span class="BigBadge">Message</span>TokenWipeAccountTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>token</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P>The token for which the account will be wiped. If token does not exist, transaction results in INVALID_TOKEN_ID</P></TD>
</TR>

<TR>
<TD>account</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account to be wiped</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>uint64</TD>
<TD><P>Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified account. Amount must be a positive non-zero number in the lowest denomination possible, not bigger than the token balance of the account (0; balance]</P></TD>
</TR>

<TR>
<TD>serialNumbers</TD>
<TD>int64 (repeated)</TD>
<TD><P>Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Transaction.proto">Transaction.proto</H2>
<a href="#title">Top</a>
</div>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer. Each Transaction should not have more than 50 levels.<BR>The SignatureList field is deprecated and succeeded by SignatureMap.</P>
<H3 id="Transaction"><span class="BigBadge">Message</span>Transaction</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signedTransactionBytes</TD>
<TD>bytes</TD>
<TD><P>SignedTransaction serialized into bytes</P></TD>
</TR>

<TR>
<TD>bodyBytes</TD>
<TD>bytes</TD>
<TD><P>TransactionBody serialized into bytes, which needs to be signed</P></TD>
</TR>

<TR>
<TD>sigMap</TD>
<TD><a href="#SignatureMap">SignatureMap</a></TD>
<TD><P>The signatures on the body with the new format, to authorize the transaction</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionBody.proto">TransactionBody.proto</H2>
<a href="#title">Top</a>
</div>
<P> A single transaction. All transaction types are possible here. </P>
<H3 id="TransactionBody"><span class="BigBadge">Message</span>TransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P>The ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P>The account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD><P>The maximum transaction fee the client is willing to pay</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD><P>The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD><P>Should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>Any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD><P>Calls a function of a contract instance</P></TD>
</TR>

<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD><P>Creates a contract instance</P></TD>
</TR>

<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD><P>Updates a contract</P></TD>
</TR>

<TR>
<TD>contractDeleteInstance</TD>
<TD><a href="#ContractDeleteTransactionBody">ContractDeleteTransactionBody</a></TD>
<TD><P>Delete contract and transfer remaining balance into specified account</P></TD>
</TR>

<TR>
<TD>cryptoAddLiveHash</TD>
<TD><a href="#CryptoAddLiveHashTransactionBody">CryptoAddLiveHashTransactionBody</a></TD>
<TD><P>Attach a new livehash to an account</P></TD>
</TR>

<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD><P>Create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD><P>Delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>cryptoDeleteLiveHash</TD>
<TD><a href="#CryptoDeleteLiveHashTransactionBody">CryptoDeleteLiveHashTransactionBody</a></TD>
<TD><P>Remove a livehash from an account</P></TD>
</TR>

<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD><P>Transfer amount between accounts</P></TD>
</TR>

<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD><P>Modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD><P>Add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD><P>Create a new file</P></TD>
</TR>

<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD><P>Delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD><P>Modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>systemDelete</TD>
<TD><a href="#SystemDeleteTransactionBody">SystemDeleteTransactionBody</a></TD>
<TD><P>Hedera administrative deletion of a file or smart contract</P></TD>
</TR>

<TR>
<TD>systemUndelete</TD>
<TD><a href="#SystemUndeleteTransactionBody">SystemUndeleteTransactionBody</a></TD>
<TD><P>To undelete an entity deleted by SystemDelete</P></TD>
</TR>

<TR>
<TD>freeze</TD>
<TD><a href="#FreezeTransactionBody">FreezeTransactionBody</a></TD>
<TD><P>Freeze the nodes</P></TD>
</TR>

<TR>
<TD>consensusCreateTopic</TD>
<TD><a href="#ConsensusCreateTopicTransactionBody">ConsensusCreateTopicTransactionBody</a></TD>
<TD><P>Creates a topic</P></TD>
</TR>

<TR>
<TD>consensusUpdateTopic</TD>
<TD><a href="#ConsensusUpdateTopicTransactionBody">ConsensusUpdateTopicTransactionBody</a></TD>
<TD><P>Updates a topic</P></TD>
</TR>

<TR>
<TD>consensusDeleteTopic</TD>
<TD><a href="#ConsensusDeleteTopicTransactionBody">ConsensusDeleteTopicTransactionBody</a></TD>
<TD><P>Deletes a topic</P></TD>
</TR>

<TR>
<TD>consensusSubmitMessage</TD>
<TD><a href="#ConsensusSubmitMessageTransactionBody">ConsensusSubmitMessageTransactionBody</a></TD>
<TD><P>Submits message to a topic</P></TD>
</TR>

<TR>
<TD>uncheckedSubmit</TD>
<TD><a href="#UncheckedSubmitBody">UncheckedSubmitBody</a></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tokenCreation</TD>
<TD><a href="#TokenCreateTransactionBody">TokenCreateTransactionBody</a></TD>
<TD><P>Creates a token instance</P></TD>
</TR>

<TR>
<TD>tokenFreeze</TD>
<TD><a href="#TokenFreezeAccountTransactionBody">TokenFreezeAccountTransactionBody</a></TD>
<TD><P>Freezes account not to be able to transact with a token</P></TD>
</TR>

<TR>
<TD>tokenUnfreeze</TD>
<TD><a href="#TokenUnfreezeAccountTransactionBody">TokenUnfreezeAccountTransactionBody</a></TD>
<TD><P>Unfreezes account for a token</P></TD>
</TR>

<TR>
<TD>tokenGrantKyc</TD>
<TD><a href="#TokenGrantKycTransactionBody">TokenGrantKycTransactionBody</a></TD>
<TD><P>Grants KYC to an account for a token</P></TD>
</TR>

<TR>
<TD>tokenRevokeKyc</TD>
<TD><a href="#TokenRevokeKycTransactionBody">TokenRevokeKycTransactionBody</a></TD>
<TD><P>Revokes KYC of an account for a token</P></TD>
</TR>

<TR>
<TD>tokenDeletion</TD>
<TD><a href="#TokenDeleteTransactionBody">TokenDeleteTransactionBody</a></TD>
<TD><P>Deletes a token instance</P></TD>
</TR>

<TR>
<TD>tokenUpdate</TD>
<TD><a href="#TokenUpdateTransactionBody">TokenUpdateTransactionBody</a></TD>
<TD><P>Updates a token instance</P></TD>
</TR>

<TR>
<TD>tokenMint</TD>
<TD><a href="#TokenMintTransactionBody">TokenMintTransactionBody</a></TD>
<TD><P>Mints new tokens to a token's treasury account</P></TD>
</TR>

<TR>
<TD>tokenBurn</TD>
<TD><a href="#TokenBurnTransactionBody">TokenBurnTransactionBody</a></TD>
<TD><P>Burns tokens from a token's treasury account</P></TD>
</TR>

<TR>
<TD>tokenWipe</TD>
<TD><a href="#TokenWipeAccountTransactionBody">TokenWipeAccountTransactionBody</a></TD>
<TD><P>Wipes amount of tokens from an account</P></TD>
</TR>

<TR>
<TD>tokenAssociate</TD>
<TD><a href="#TokenAssociateTransactionBody">TokenAssociateTransactionBody</a></TD>
<TD><P>Associate tokens to an account</P></TD>
</TR>

<TR>
<TD>tokenDissociate</TD>
<TD><a href="#TokenDissociateTransactionBody">TokenDissociateTransactionBody</a></TD>
<TD><P>Dissociate tokens from an account</P></TD>
</TR>

<TR>
<TD>scheduleCreate</TD>
<TD><a href="#ScheduleCreateTransactionBody">ScheduleCreateTransactionBody</a></TD>
<TD><P>Creates a schedule in the network's action queue</P></TD>
</TR>

<TR>
<TD>scheduleDelete</TD>
<TD><a href="#ScheduleDeleteTransactionBody">ScheduleDeleteTransactionBody</a></TD>
<TD><P>Deletes a schedule from the network's action queue</P></TD>
</TR>

<TR>
<TD>scheduleSign</TD>
<TD><a href="#ScheduleSignTransactionBody">ScheduleSignTransactionBody</a></TD>
<TD><P>Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction</P></TD>
</TR>

<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionContents.proto">TransactionContents.proto</H2>
<a href="#title">Top</a>
</div>
<P>-<BR>‌<BR>Hedera Network Services Protobuf<BR>​<BR>Copyright (C) 2018 - 2021 Hedera Hashgraph, LLC<BR>​<BR>Licensed under the Apache License, Version 2.0 (the "License");<BR>you may not use this file except in compliance with the License.<BR>You may obtain a copy of the License at<BR>http:www.apache.org/licenses/LICENSE-2.0<BR>Unless required by applicable law or agreed to in writing, software<BR>distributed under the License is distributed on an "AS IS" BASIS,<BR>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<BR>See the License for the specific language governing permissions and<BR>limitations under the License.<BR>‍</P>
<H3 id="SignedTransaction"><span class="BigBadge">Message</span>SignedTransaction</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>bodyBytes</TD>
<TD>bytes</TD>
<TD><P>TransactionBody serialized into bytes, which needs to be signed</P></TD>
</TR>

<TR>
<TD>sigMap</TD>
<TD><a href="#SignatureMap">SignatureMap</a></TD>
<TD><P>The signatures on the body with the new format, to authorize the transaction</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionGetFastRecord.proto">TransactionGetFastRecord.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the tx record of a transaction, given its transaction ID. Once a transaction reaches consensus, then information about whether it succeeded or failed will be available until the end of the receipt period.  Before and after the receipt period, and for a transaction that was never submitted, the receipt is unknown.  This query is free (the payment field is left empty). </P>
<H3 id="TransactionGetFastRecordQuery"><span class="BigBadge">Message</span>TransactionGetFastRecordQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P>The ID of the transaction for which the record is requested.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TransactionGetFastRecordResponse"><span class="BigBadge">Message</span>TransactionGetFastRecordResponse</H3>
<P> Response when the client sends the node TransactionGetFastRecordQuery. If it created a new entity (account, file, or smart contract instance) then one of the three ID fields will be filled in with the ID of the new entity. Sometimes a single transaction will create more than one new entity, such as when a new contract instance is created, and this also creates the new account that it owned by that instance. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>transactionRecord</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD><P>The requested transaction records</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionGetReceipt.proto">TransactionGetReceipt.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus, then information about whether it succeeded or failed will be available until the end of the receipt period.  Before and after the receipt period, and for a transaction that was never submitted, the receipt is unknown.  This query is free (the payment field is left empty). No State proof is available for this response</P>
<H3 id="TransactionGetReceiptQuery"><span class="BigBadge">Message</span>TransactionGetReceiptQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P>The ID of the transaction for which the receipt is requested.</P></TD>
</TR>

<TR>
<TD>includeDuplicates</TD>
<TD>bool</TD>
<TD><P>Whether receipts of processing duplicate transactions should be returned along with the receipt of processing the first consensus transaction with the given id whose status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such receipt exists, the receipt of processing the first transaction to reach consensus with the given transaction id..</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TransactionGetReceiptResponse"><span class="BigBadge">Message</span>TransactionGetReceiptResponse</H3>
<P> Response when the client sends the node TransactionGetReceiptQuery. If it created a new entity (account, file, or smart contract instance) then one of the three ID fields will be filled in with the ID of the new entity. Sometimes a single transaction will create more than one new entity, such as when a new contract instance is created, and this also creates the new account that it owned by that instance. No State proof is available for this response </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD><P>Either the receipt of processing the first consensus transaction with the given id whose status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such receipt exists, the receipt of processing the first transaction to reach consensus with the given transaction id.</P></TD>
</TR>

<TR>
<TD>duplicateTransactionReceipts</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a> (repeated)</TD>
<TD><P>The receipts of processing all consensus transaction with the same id as the distinguished receipt above, in chronological order.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionGetRecord.proto">TransactionGetRecord.proto</H2>
<a href="#title">Top</a>
</div>
<P> Get the record for a transaction. If the transaction requested a record, then the record lasts for one hour, and a state proof is available for it. If the transaction created an account, file, or smart contract instance, then the record will contain the ID for what it created. If the transaction called a smart contract function, then the record contains the result of that call. If the transaction was a cryptocurrency transfer, then the record includes the TransferList which gives the details of that transfer. If the transaction didn't return anything that should be in the record, then the results field will be set to nothing. </P>
<H3 id="TransactionGetRecordQuery"><span class="BigBadge">Message</span>TransactionGetRecordQuery</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD><P>Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P>The ID of the transaction for which the record is requested.</P></TD>
</TR>

<TR>
<TD>includeDuplicates</TD>
<TD>bool</TD>
<TD><P>Whether records of processing duplicate transactions should be returned along with the record of processing the first consensus transaction with the given id whose status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such record exists, the record of processing the first transaction to reach consensus with the given transaction id..</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TransactionGetRecordResponse"><span class="BigBadge">Message</span>TransactionGetRecordResponse</H3>
<P> Response when the client sends the node TransactionGetRecordQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD><P>Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.</P></TD>
</TR>

<TR>
<TD>transactionRecord</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD><P>Either the record of processing the first consensus transaction with the given id whose status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such record exists, the record of processing the first transaction to reach consensus with the given transaction id.</P></TD>
</TR>

<TR>
<TD>duplicateTransactionRecords</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a> (repeated)</TD>
<TD><P>The records of processing all consensus transaction with the same id as the distinguished record above, in chronological order.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionReceipt.proto">TransactionReceipt.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TransactionReceipt"><span class="BigBadge">Message</span>TransactionReceipt</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#ResponseCodeEnum">ResponseCodeEnum</a></TD>
<TD><P> The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if the<BR>associated transaction did not have a valid payer signature</P></TD>
</TR>

<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD><P> In the receipt of a CryptoCreate, the id of the newly created account</P></TD>
</TR>

<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD><P> In the receipt of a FileCreate, the id of the newly created file</P></TD>
</TR>

<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD><P> In the receipt of a ContractCreate, the id of the newly created contract</P></TD>
</TR>

<TR>
<TD>exchangeRate</TD>
<TD><a href="#ExchangeRateSet">ExchangeRateSet</a></TD>
<TD><P> The exchange rates in effect when the transaction reached consensus</P></TD>
</TR>

<TR>
<TD>topicID</TD>
<TD><a href="#TopicID">TopicID</a></TD>
<TD><P> In the receipt of a ConsensusCreateTopic, the id of the newly created topic.</P></TD>
</TR>

<TR>
<TD>topicSequenceNumber</TD>
<TD>uint64</TD>
<TD><P> In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that received the message</P></TD>
</TR>

<TR>
<TD>topicRunningHash</TD>
<TD>bytes</TD>
<TD><P> In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received the message.<BR>This 48-byte field is the output of a particular SHA-384 digest whose input data are determined by the<BR>value of the topicRunningHashVersion below. The bytes of each uint64 or uint32 are to be in Big-Endian<BR>format.<BR><BR>IF the topicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are, in order:<BR>---<BR>1. The previous running hash of the topic (48 bytes)<BR>2. The topic's shard (8 bytes)<BR>3. The topic's realm (8 bytes)<BR>4. The topic's number (8 bytes)<BR>5. The number of seconds since the epoch before the ConsensusSubmitMessage reached consensus (8 bytes)<BR>6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached consensus (4 bytes)<BR>7. The topicSequenceNumber from above (8 bytes)<BR>8. The message bytes from the ConsensusSubmitMessage (variable).<BR><BR>IF the topicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in order:<BR>---<BR>1. The previous running hash of the topic (48 bytes)<BR>2. The topicRunningHashVersion below (8 bytes)<BR>3. The topic's shard (8 bytes)<BR>4. The topic's realm (8 bytes)<BR>5. The topic's number (8 bytes)<BR>6. The number of seconds since the epoch before the ConsensusSubmitMessage reached consensus (8 bytes)<BR>7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached consensus (4 bytes)<BR>8. The topicSequenceNumber from above (8 bytes)<BR>9. The output of the SHA-384 digest of the message bytes from the consensusSubmitMessage (48 bytes)<BR><BR>Otherwise, IF the topicRunningHashVersion is '3', then the input data to the SHA-384 digest are, in order:<BR>---<BR>1. The previous running hash of the topic (48 bytes)<BR>2. The topicRunningHashVersion below (8 bytes)<BR>3. The payer account's shard (8 bytes)<BR>4. The payer account's realm (8 bytes)<BR>5. The payer account's number (8 bytes)<BR>6. The topic's shard (8 bytes)<BR>7. The topic's realm (8 bytes)<BR>8. The topic's number (8 bytes)<BR>9. The number of seconds since the epoch before the ConsensusSubmitMessage reached consensus (8 bytes)<BR>10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached consensus (4 bytes)<BR>11. The topicSequenceNumber from above (8 bytes)<BR>12. The output of the SHA-384 digest of the message bytes from the consensusSubmitMessage (48 bytes)</P></TD>
</TR>

<TR>
<TD>topicRunningHashVersion</TD>
<TD>uint64</TD>
<TD><P> In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update the running hash.</P></TD>
</TR>

<TR>
<TD>tokenID</TD>
<TD><a href="#TokenID">TokenID</a></TD>
<TD><P> In the receipt of a CreateToken, the id of the newly created token</P></TD>
</TR>

<TR>
<TD>newTotalSupply</TD>
<TD>uint64</TD>
<TD><P> In the receipt of TokenMint, TokenWipe, TokenBurn, the current total supply of this token</P></TD>
</TR>

<TR>
<TD>scheduleID</TD>
<TD><a href="#ScheduleID">ScheduleID</a></TD>
<TD><P> In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity</P></TD>
</TR>

<TR>
<TD>scheduledTransactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P> In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the TransactionID that should be used to query for the receipt or record of the relevant scheduled transaction</P></TD>
</TR>

<TR>
<TD>serialNumbers</TD>
<TD>int64 (repeated)</TD>
<TD><P> In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of the newly created NFTs</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionRecord.proto">TransactionRecord.proto</H2>
<a href="#title">Top</a>
</div>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<H3 id="TransactionRecord"><span class="BigBadge">Message</span>TransactionRecord</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD><P>The status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD><P>The hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD><P>The consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD><P>The ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD><P>The memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD><P>The actual transaction fee charged, not the original transactionFee value from TransactionBody</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=2>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD><P>Record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD><P>Record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<tbody>
</TABLE>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD><P>All hbar transfers as a result of this transaction, such as fees, or transfers performed by the transaction, or by a smart contract it calls, or by the creation of threshold records that it triggers.</P></TD>
</TR>

<TR>
<TD>tokenTransferLists</TD>
<TD><a href="#TokenTransferList">TokenTransferList</a> (repeated)</TD>
<TD><P>All Token transfers as a result of this transaction</P></TD>
</TR>

<TR>
<TD>scheduleRef</TD>
<TD><a href="#ScheduleID">ScheduleID</a></TD>
<TD><P>Reference to the scheduled transaction ID that this transaction record represent</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionResponse.proto">TransactionResponse.proto</H2>
<a href="#title">Top</a>
</div>
<P> When the client sends the node a transaction of any kind, the node replies with this, which simply says that the transaction passed the precheck (so the node will submit it to the network) or it failed (so it won't). If the fee offered was insufficient, this will also contain the amount of the required fee. To learn the consensus result, the client should later obtain a receipt (free), or can buy a more detailed record (not free). </P>
<H3 id="TransactionResponse"><span class="BigBadge">Message</span>TransactionResponse</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#ResponseCodeEnum">ResponseCodeEnum</a></TD>
<TD><P>The response code that indicates the current status of the transaction.</P></TD>
</TR>

<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD><P>If the response code was INSUFFICIENT_TX_FEE, the actual transaction fee that would be required to execute the transaction.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="UncheckedSubmit.proto">UncheckedSubmit.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="UncheckedSubmitBody"><span class="BigBadge">Message</span>UncheckedSubmitBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionBytes</TD>
<TD>bytes</TD>
<TD><P>The serialized bytes of the Transaction to be submitted without prechecks</P></TD>
</TR>

<tbody>
</TABLE>

</div></div></body>