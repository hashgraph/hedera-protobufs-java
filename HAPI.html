<!DOCTYPE html><html>  <head>    <title>HAPI Documentation</title>    <meta charset="UTF-8">    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>    <style>    	#content, html, body {	    height: 100%;	}	#left {	    height: 100%;    	width:25%;    	float: left;    	overflow-y: auto;	}   	#right {	    height: 100%;    	width:75%;    	float: right;    	overflow-y: auto;	}         body {        width: 100%;        margin: 1em auto;        color: #222;        font-family: "Ubuntu", sans-serif;        padding-bottom: 4em;      }      h1 {        font-weight: normal;        border-bottom: 1px solid #aaa;        padding-bottom: 0.5ex;      }      h2 {        border-bottom: 1px solid #aaa;        padding-bottom: 0.5ex;        margin: 1.5em 0;      }      h3 {        font-weight: normal;        border-bottom: 1px solid #aaa;        padding-bottom: 0.5ex;      }      a {        text-decoration: none;        color: #0645AD;      }      p { /* Comments */        color: #567e25;      }      table {        width: 100%;        font-size: 95%;        border-collapse: collapse;      }      thead {        font-weight: 700;        background-color: #dcdcdc;      }      tbody tr:nth-child(even) {        background-color: #fbfbfb;      }      td {        border: 1px solid #ccc;        padding: 0.5ex 2ex;      }      td p {        text-indent: 1em;        margin: 0;      }      td p:nth-child(1) {        text-indent: 0; /* No indent on first p in td */      }      /* Table of fields */      .field-table td:nth-child(1) { /* Field */        width: 10em;      }      .field-table td:nth-child(2) { /* Type */        width: 10em;      }      .field-table td:nth-child(3) { /* Label */        width: 6em;      }      .field-table td:nth-child(4) { /* Description */        width: auto;      }      /* Table of extensions */      .extension-table td:nth-child(1) { /* Extension */        width: 10em;      }      .extension-table td:nth-child(2) { /* Type */        width: 10em;      }      .extension-table td:nth-child(3) { /* Base */        width: 10em;      }      .extension-table td:nth-child(4) { /* Number */        width: 5em;      }      .extension-table td:nth-child(5) { /* Description */        width: auto;      }      /* Table of enum values. */      .enum-table td:nth-child(1) { /* Name */        width: 10em;      }      .enum-table td:nth-child(2) { /* Number */        width: 10em;      }      .enum-table td:nth-child(3) { /* Description */        width: auto;      }      /* Table of scalar value types. */      .scalar-value-types-table tr {        height: 3em;      }      /* Table of contents. */      #toc-container ul {        list-style-type: none;        padding-left: 1em;        line-height: 180%;        margin: 0;        overflow-wrap: break-word;  		word-wrap: break-word;      }      #toc > li > a {        font-weight: bold;        overflow-wrap: break-word;  		word-wrap: break-word;      }      /* File heading div */      .file-heading {        width: 100%;        display: table;        border-bottom: 1px solid #aaa;        margin: 4em 0 1.5em 0;      }      .file-heading h2 {        border: none;        display: table-cell;      }      .file-heading a {        text-align: right;        display: table-cell;      }      /* The 'M', 'E' and 'X' badges in the ToC */      .badge {        width: 1.6em;        height: 1.6em;        display: inline-block;        line-height: 1.6em;        text-align: center;        font-weight: bold;        font-size: 60%;        color: #d9534f;        background-color: #dff0c8;        margin: 0.5ex 1em 0.5ex -1em;        border: 1px solid #fbfbfb;        border-radius: 1ex;      }      .BigBadge {        height: 2.2em;        display: inline-block;        line-height: 2.2em;        text-align: center;        font-weight: bold;        font-size: 100%;        color: #d9534f;        background-color: #dff0c8;        margin: 0.5ex 1em 0.5ex 0em;        border: 1px solid #fbfbfb;        border-radius: 1ex;      }          </style>    <!-- User custom CSS -->    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>  </head>  <body><div id="content"><div id="left"><h2>Table of Contents</h2>
<p>
<div id="toc-container">
<ul id="toc">
<li>
<a href=#AdminDelete.proto>AdminDelete.proto</a>
<ul>
<li>
<a href="#AdminDeleteTransactionBody"><span class="badge">M</span>AdminDeleteTransactionBody</a></li>
</ul>
<a href=#AdminUndelete.proto>AdminUndelete.proto</a>
<ul>
<li>
<a href="#AdminUndeleteTransactionBody"><span class="badge">M</span>AdminUndeleteTransactionBody</a></li>
</ul>
<a href=#BasicTypes.proto>BasicTypes.proto</a>
<ul>
<li>
<a href="#AccountID"><span class="badge">M</span>AccountID</a></li>
<li>
<a href="#ContractID"><span class="badge">M</span>ContractID</a></li>
<li>
<a href="#FeeComponents"><span class="badge">M</span>FeeComponents</a></li>
<li>
<a href="#FeeData"><span class="badge">M</span>FeeData</a></li>
<li>
<a href="#FeeSchedule"><span class="badge">M</span>FeeSchedule</a></li>
<li>
<a href="#FileID"><span class="badge">M</span>FileID</a></li>
<li>
<a href="#HederaFunctionality"><span class="badge">E</span>HederaFunctionality</a></li>
<li>
<a href="#Key"><span class="badge">M</span>Key</a></li>
<li>
<a href="#KeyList"><span class="badge">M</span>KeyList</a></li>
<li>
<a href="#NodeAddress"><span class="badge">M</span>NodeAddress</a></li>
<li>
<a href="#NodeAddressBook"><span class="badge">M</span>NodeAddressBook</a></li>
<li>
<a href="#RealmID"><span class="badge">M</span>RealmID</a></li>
<li>
<a href="#ShardID"><span class="badge">M</span>ShardID</a></li>
<li>
<a href="#Signature"><span class="badge">M</span>Signature</a></li>
<li>
<a href="#SignatureList"><span class="badge">M</span>SignatureList</a></li>
<li>
<a href="#ThresholdKey"><span class="badge">M</span>ThresholdKey</a></li>
<li>
<a href="#ThresholdSignature"><span class="badge">M</span>ThresholdSignature</a></li>
<li>
<a href="#TransactionFeeSchedule"><span class="badge">M</span>TransactionFeeSchedule</a></li>
<li>
<a href="#TransactionID"><span class="badge">M</span>TransactionID</a></li>
</ul>
<a href=#ContractCall.proto>ContractCall.proto</a>
<ul>
<li>
<a href="#ContractCallTransactionBody"><span class="badge">M</span>ContractCallTransactionBody</a></li>
</ul>
<a href=#ContractCallLocal.proto>ContractCallLocal.proto</a>
<ul>
<li>
<a href="#ContractCallLocalQuery"><span class="badge">M</span>ContractCallLocalQuery</a></li>
<li>
<a href="#ContractCallLocalResponse"><span class="badge">M</span>ContractCallLocalResponse</a></li>
<li>
<a href="#ContractFunctionResult"><span class="badge">M</span>ContractFunctionResult</a></li>
<li>
<a href="#ContractLoginfo"><span class="badge">M</span>ContractLoginfo</a></li>
</ul>
<a href=#ContractCreate.proto>ContractCreate.proto</a>
<ul>
<li>
<a href="#ContractCreateTransactionBody"><span class="badge">M</span>ContractCreateTransactionBody</a></li>
</ul>
<a href=#ContractGetBytecode.proto>ContractGetBytecode.proto</a>
<ul>
<li>
<a href="#ContractGetBytecodeQuery"><span class="badge">M</span>ContractGetBytecodeQuery</a></li>
<li>
<a href="#ContractGetBytecodeResponse"><span class="badge">M</span>ContractGetBytecodeResponse</a></li>
</ul>
<a href=#ContractGetInfo.proto>ContractGetInfo.proto</a>
<ul>
<li>
<a href="#ContractGetInfoQuery"><span class="badge">M</span>ContractGetInfoQuery</a></li>
<li>
<a href="#ContractGetInfoResponse"><span class="badge">M</span>ContractGetInfoResponse</a></li>
<li>
<a href="#ContractGetInfoResponse.ContractInfo"><span class="badge">M</span>ContractGetInfoResponse.ContractInfo</a></li>
</ul>
<a href=#ContractGetRecords.proto>ContractGetRecords.proto</a>
<ul>
<li>
<a href="#ContractGetRecordsQuery"><span class="badge">M</span>ContractGetRecordsQuery</a></li>
<li>
<a href="#ContractGetRecordsResponse"><span class="badge">M</span>ContractGetRecordsResponse</a></li>
</ul>
<a href=#ContractUpdate.proto>ContractUpdate.proto</a>
<ul>
<li>
<a href="#ContractUpdateTransactionBody"><span class="badge">M</span>ContractUpdateTransactionBody</a></li>
</ul>
<a href=#CreateFeeSchedule.proto>CreateFeeSchedule.proto</a>
<ul>
<li>
<a href="#CreateFeeScheduleTransactionBody"><span class="badge">M</span>CreateFeeScheduleTransactionBody</a></li>
</ul>
<a href=#CryptoAddClaim.proto>CryptoAddClaim.proto</a>
<ul>
<li>
<a href="#Claim"><span class="badge">M</span>Claim</a></li>
<li>
<a href="#CryptoAddClaimTransactionBody"><span class="badge">M</span>CryptoAddClaimTransactionBody</a></li>
</ul>
<a href=#CryptoCreate.proto>CryptoCreate.proto</a>
<ul>
<li>
<a href="#CryptoCreateTransactionBody"><span class="badge">M</span>CryptoCreateTransactionBody</a></li>
</ul>
<a href=#CryptoDelete.proto>CryptoDelete.proto</a>
<ul>
<li>
<a href="#CryptoDeleteTransactionBody"><span class="badge">M</span>CryptoDeleteTransactionBody</a></li>
</ul>
<a href=#CryptoDeleteClaim.proto>CryptoDeleteClaim.proto</a>
<ul>
<li>
<a href="#CryptoDeleteClaimTransactionBody"><span class="badge">M</span>CryptoDeleteClaimTransactionBody</a></li>
</ul>
<a href=#CryptoGetAccountBalance.proto>CryptoGetAccountBalance.proto</a>
<ul>
<li>
<a href="#CryptoGetAccountBalanceQuery"><span class="badge">M</span>CryptoGetAccountBalanceQuery</a></li>
<li>
<a href="#CryptoGetAccountBalanceResponse"><span class="badge">M</span>CryptoGetAccountBalanceResponse</a></li>
</ul>
<a href=#CryptoGetAccountRecords.proto>CryptoGetAccountRecords.proto</a>
<ul>
<li>
<a href="#CryptoGetAccountRecordsQuery"><span class="badge">M</span>CryptoGetAccountRecordsQuery</a></li>
<li>
<a href="#CryptoGetAccountRecordsResponse"><span class="badge">M</span>CryptoGetAccountRecordsResponse</a></li>
</ul>
<a href=#CryptoGetClaim.proto>CryptoGetClaim.proto</a>
<ul>
<li>
<a href="#CryptoGetClaimQuery"><span class="badge">M</span>CryptoGetClaimQuery</a></li>
<li>
<a href="#CryptoGetClaimResponse"><span class="badge">M</span>CryptoGetClaimResponse</a></li>
</ul>
<a href=#CryptoGetInfo.proto>CryptoGetInfo.proto</a>
<ul>
<li>
<a href="#CryptoGetInfoQuery"><span class="badge">M</span>CryptoGetInfoQuery</a></li>
<li>
<a href="#CryptoGetInfoResponse"><span class="badge">M</span>CryptoGetInfoResponse</a></li>
<li>
<a href="#CryptoGetInfoResponse.AccountInfo"><span class="badge">M</span>CryptoGetInfoResponse.AccountInfo</a></li>
</ul>
<a href=#CryptoGetStakers.proto>CryptoGetStakers.proto</a>
<ul>
<li>
<a href="#AllProxyStakers"><span class="badge">M</span>AllProxyStakers</a></li>
<li>
<a href="#CryptoGetStakersQuery"><span class="badge">M</span>CryptoGetStakersQuery</a></li>
<li>
<a href="#CryptoGetStakersResponse"><span class="badge">M</span>CryptoGetStakersResponse</a></li>
<li>
<a href="#ProxyStaker"><span class="badge">M</span>ProxyStaker</a></li>
</ul>
<a href=#CryptoService.proto>CryptoService.proto</a>
<ul>
</ul>
<a href=#CryptoTransfer.proto>CryptoTransfer.proto</a>
<ul>
<li>
<a href="#AccountAmount"><span class="badge">M</span>AccountAmount</a></li>
<li>
<a href="#CryptoTransferTransactionBody"><span class="badge">M</span>CryptoTransferTransactionBody</a></li>
<li>
<a href="#TransferList"><span class="badge">M</span>TransferList</a></li>
</ul>
<a href=#CryptoUpdate.proto>CryptoUpdate.proto</a>
<ul>
<li>
<a href="#CryptoUpdateTransactionBody"><span class="badge">M</span>CryptoUpdateTransactionBody</a></li>
</ul>
<a href=#Duration.proto>Duration.proto</a>
<ul>
<li>
<a href="#Duration"><span class="badge">M</span>Duration</a></li>
</ul>
<a href=#FileAppend.proto>FileAppend.proto</a>
<ul>
<li>
<a href="#FileAppendTransactionBody"><span class="badge">M</span>FileAppendTransactionBody</a></li>
</ul>
<a href=#FileCreate.proto>FileCreate.proto</a>
<ul>
<li>
<a href="#FileCreateTransactionBody"><span class="badge">M</span>FileCreateTransactionBody</a></li>
</ul>
<a href=#FileDelete.proto>FileDelete.proto</a>
<ul>
<li>
<a href="#FileDeleteTransactionBody"><span class="badge">M</span>FileDeleteTransactionBody</a></li>
</ul>
<a href=#FileGetContents.proto>FileGetContents.proto</a>
<ul>
<li>
<a href="#FileGetContentsQuery"><span class="badge">M</span>FileGetContentsQuery</a></li>
<li>
<a href="#FileGetContentsResponse"><span class="badge">M</span>FileGetContentsResponse</a></li>
<li>
<a href="#FileGetContentsResponse.FileContents"><span class="badge">M</span>FileGetContentsResponse.FileContents</a></li>
</ul>
<a href=#FileGetInfo.proto>FileGetInfo.proto</a>
<ul>
<li>
<a href="#FileGetInfoQuery"><span class="badge">M</span>FileGetInfoQuery</a></li>
<li>
<a href="#FileGetInfoResponse"><span class="badge">M</span>FileGetInfoResponse</a></li>
<li>
<a href="#FileGetInfoResponse.FileInfo"><span class="badge">M</span>FileGetInfoResponse.FileInfo</a></li>
</ul>
<a href=#FileService.proto>FileService.proto</a>
<ul>
</ul>
<a href=#FileUpdate.proto>FileUpdate.proto</a>
<ul>
<li>
<a href="#FileUpdateTransactionBody"><span class="badge">M</span>FileUpdateTransactionBody</a></li>
</ul>
<a href=#GetByKey.proto>GetByKey.proto</a>
<ul>
<li>
<a href="#EntityID"><span class="badge">M</span>EntityID</a></li>
<li>
<a href="#GetByKeyQuery"><span class="badge">M</span>GetByKeyQuery</a></li>
<li>
<a href="#GetByKeyResponse"><span class="badge">M</span>GetByKeyResponse</a></li>
</ul>
<a href=#GetBySolidityID.proto>GetBySolidityID.proto</a>
<ul>
<li>
<a href="#GetBySolidityIDQuery"><span class="badge">M</span>GetBySolidityIDQuery</a></li>
<li>
<a href="#GetBySolidityIDResponse"><span class="badge">M</span>GetBySolidityIDResponse</a></li>
</ul>
<a href=#Query.proto>Query.proto</a>
<ul>
<li>
<a href="#Query"><span class="badge">M</span>Query</a></li>
</ul>
<a href=#QueryHeader.proto>QueryHeader.proto</a>
<ul>
<li>
<a href="#QueryHeader"><span class="badge">M</span>QueryHeader</a></li>
<li>
<a href="#ResponseType"><span class="badge">E</span>ResponseType</a></li>
</ul>
<a href=#Response.proto>Response.proto</a>
<ul>
<li>
<a href="#Response"><span class="badge">M</span>Response</a></li>
</ul>
<a href=#ResponseHeader.proto>ResponseHeader.proto</a>
<ul>
<li>
<a href="#ResponseHeader"><span class="badge">M</span>ResponseHeader</a></li>
</ul>
<a href=#SmartContractService.proto>SmartContractService.proto</a>
<ul>
</ul>
<a href=#Timestamp.proto>Timestamp.proto</a>
<ul>
<li>
<a href="#Timestamp"><span class="badge">M</span>Timestamp</a></li>
<li>
<a href="#TimestampSeconds"><span class="badge">M</span>TimestampSeconds</a></li>
</ul>
<a href=#Transaction.proto>Transaction.proto</a>
<ul>
<li>
<a href="#Transaction"><span class="badge">M</span>Transaction</a></li>
<li>
<a href="#TransactionBody"><span class="badge">M</span>TransactionBody</a></li>
</ul>
<a href=#TransactionGetReceipt.proto>TransactionGetReceipt.proto</a>
<ul>
<li>
<a href="#TransactionGetReceiptQuery"><span class="badge">M</span>TransactionGetReceiptQuery</a></li>
<li>
<a href="#TransactionGetReceiptResponse"><span class="badge">M</span>TransactionGetReceiptResponse</a></li>
</ul>
<a href=#TransactionGetRecord.proto>TransactionGetRecord.proto</a>
<ul>
<li>
<a href="#TransactionGetRecordQuery"><span class="badge">M</span>TransactionGetRecordQuery</a></li>
<li>
<a href="#TransactionGetRecordResponse"><span class="badge">M</span>TransactionGetRecordResponse</a></li>
</ul>
<a href=#TransactionReceipt.proto>TransactionReceipt.proto</a>
<ul>
<li>
<a href="#TransactionReceipt"><span class="badge">M</span>TransactionReceipt</a></li>
<li>
<a href="#TransactionStatus"><span class="badge">E</span>TransactionStatus</a></li>
</ul>
<a href=#TransactionRecord.proto>TransactionRecord.proto</a>
<ul>
<li>
<a href="#TransactionRecord"><span class="badge">M</span>TransactionRecord</a></li>
</ul>
<a href=#TransactionResponse.proto>TransactionResponse.proto</a>
<ul>
<li>
<a href="#NodeTransactionPrecheckCode"><span class="badge">E</span>NodeTransactionPrecheckCode</a></li>
<li>
<a href="#TransactionResponse"><span class="badge">M</span>TransactionResponse</a></li>
</ul>
</li>
</ul>
</div>
</p>
</div><div id="right"><h1 id="title">HAPI Documentation</h1>
<div class="file-heading">
<H2 id="AdminDelete.proto">AdminDelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="AdminDeleteTransactionBody"><span class="BigBadge">Message</span>AdminDeleteTransactionBody</H3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="AdminUndelete.proto">AdminUndelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="AdminUndeleteTransactionBody"><span class="BigBadge">Message</span>AdminUndeleteTransactionBody</H3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="BasicTypes.proto">BasicTypes.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="AccountID"><span class="BigBadge">Message</span>AccountID</H3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractID"><span class="BigBadge">Message</span>ContractID</H3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FeeComponents"><span class="BigBadge">Message</span>FeeComponents</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="FeeData"><span class="BigBadge">Message</span>FeeData</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged by Node for this functionality</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>networkdata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for network operations by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>servicedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for provding service by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="FeeSchedule"><span class="BigBadge">Message</span>FeeSchedule</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionFeeSchedule</TD>
<TD><a href="#TransactionFeeSchedule">TransactionFeeSchedule</a></TD>
<TD>repeated</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>hederaFunctionality</TD>
<TD><a href="#HederaFunctionality">HederaFunctionality</a></TD>
<TD>&nbsp;</TD>
<TD><P>Specific Transaction or Query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>CryptoCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoTransfer</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoAddClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDeletClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCall</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileAppend</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountBalance</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountRecords</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCallLocal</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetBytecode</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetBySolidityID</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetByKey</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetStakers</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetContents</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>TransactionGetRecord</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>feeData</TD>
<TD><a href="#FeeData">FeeData</a></TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged by Node for this functionality</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>networkdata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for network operations by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>servicedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for provding service by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>feeScheduleValidityDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="FileID"><span class="BigBadge">Message</span>FileID</H3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="HederaFunctionality"><span class="BigBadge">Enum</span>HederaFunctionality</H3>
<P></P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>CryptoCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoTransfer</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoAddClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDeletClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCall</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileAppend</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountBalance</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountRecords</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCallLocal</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetBytecode</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetBySolidityID</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetByKey</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetStakers</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetContents</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>TransactionGetRecord</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="Key"><span class="BigBadge">Message</span>Key</H3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="KeyList"><span class="BigBadge">Message</span>KeyList</H3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="NodeAddress"><span class="BigBadge">Message</span>NodeAddress</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ipAddress</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>portno</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="NodeAddressBook"><span class="BigBadge">Message</span>NodeAddressBook</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeAddress</TD>
<TD><a href="#NodeAddress">NodeAddress</a></TD>
<TD>repeated</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ipAddress</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>portno</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="RealmID"><span class="BigBadge">Message</span>RealmID</H3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ShardID"><span class="BigBadge">Message</span>ShardID</H3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="Signature"><span class="BigBadge">Message</span>Signature</H3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="SignatureList"><span class="BigBadge">Message</span>SignatureList</H3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ThresholdKey"><span class="BigBadge">Message</span>ThresholdKey</H3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ThresholdSignature"><span class="BigBadge">Message</span>ThresholdSignature</H3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="TransactionFeeSchedule"><span class="BigBadge">Message</span>TransactionFeeSchedule</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>hederaFunctionality</TD>
<TD><a href="#HederaFunctionality">HederaFunctionality</a></TD>
<TD>&nbsp;</TD>
<TD><P>Specific Transaction or Query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>CryptoCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoTransfer</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoAddClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDeletClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCall</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileAppend</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountBalance</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountRecords</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCallLocal</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetBytecode</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetBySolidityID</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetByKey</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetStakers</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetContents</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>TransactionGetRecord</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>feeData</TD>
<TD><a href="#FeeData">FeeData</a></TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged by Node for this functionality</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>networkdata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for network operations by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>servicedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for provding service by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="TransactionID"><span class="BigBadge">Message</span>TransactionID</H3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractCall.proto">ContractCall.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractCallTransactionBody"><span class="BigBadge">Message</span>ContractCallTransactionBody</H3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractCallLocal.proto">ContractCallLocal.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractCallLocalQuery"><span class="BigBadge">Message</span>ContractCallLocalQuery</H3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. It can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<TR>
<TD>maxResultSize</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="ContractCallLocalResponse"><span class="BigBadge">Message</span>ContractCallLocalResponse</H3>
<P> Response when the client sends the node ContractCallLocalQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>functionResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>the value returned by the function (if it completed and didn't fail)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ContractFunctionResult"><span class="BigBadge">Message</span>ContractFunctionResult</H3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ContractLoginfo"><span class="BigBadge">Message</span>ContractLoginfo</H3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractCreate.proto">ContractCreate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractCreateTransactionBody"><span class="BigBadge">Message</span>ContractCreateTransactionBody</H3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractGetBytecode.proto">ContractGetBytecode.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractGetBytecodeQuery"><span class="BigBadge">Message</span>ContractGetBytecodeQuery</H3>
<P> Get the bytecode for a smart contract instance </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ContractGetBytecodeResponse"><span class="BigBadge">Message</span>ContractGetBytecodeResponse</H3>
<P> Response when the client sends the node ContractGetBytecodeQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bytecode</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytecode</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractGetInfo.proto">ContractGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractGetInfoQuery"><span class="BigBadge">Message</span>ContractGetInfoQuery</H3>
<P> Get information about a smart contract instance. This includes the account that it uses, the file containing its bytecode, and the time when it will expire. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ContractGetInfoResponse"><span class="BigBadge">Message</span>ContractGetInfoResponse</H3>
<P> Response when the client sends the node ContractGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractInfo</TD>
<TD><a href="#ContractGetInfoResponse.ContractInfo">ContractGetInfoResponse.ContractInfo</a></TD>
<TD>&nbsp;</TD>
<TD><P>the information about this contract instance (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node ContractGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the cryptocurrency account owned by the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>ID of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this contract instance (and its account) is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If the account is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>storage</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of bytes of storage being used by this instance (which affects the cost to extend the expiration time)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ContractGetInfoResponse.ContractInfo"><span class="BigBadge">Message</span>ContractGetInfoResponse.ContractInfo</H3>
<P> Response when the client sends the node ContractGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the cryptocurrency account owned by the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>ID of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this contract instance (and its account) is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If the account is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>storage</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of bytes of storage being used by this instance (which affects the cost to extend the expiration time)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractGetRecords.proto">ContractGetRecords.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractGetRecordsQuery"><span class="BigBadge">Message</span>ContractGetRecordsQuery</H3>
<P> Get all the records for a smart contract instance, for any function call (or the constructor call) during the last 24 hours, for which a Record was requested. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance for which the records should be retrieved</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ContractGetRecordsResponse"><span class="BigBadge">Message</span>ContractGetRecordsResponse</H3>
<P> Response when the client sends the node ContractGetRecordsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance that this record is for</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>records</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD>repeated</TD>
<TD><P>list of records, each with contractCreateResult or contractCallResult as its body</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)_</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the transaction fee in the transaction</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of results of a CryptoTransferTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ContractUpdate.proto">ContractUpdate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ContractUpdateTransactionBody"><span class="BigBadge">Message</span>ContractUpdateTransactionBody</H3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CreateFeeSchedule.proto">CreateFeeSchedule.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CreateFeeScheduleTransactionBody"><span class="BigBadge">Message</span>CreateFeeScheduleTransactionBody</H3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign to update the Fee Schedule</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFeeSchedule</TD>
<TD><a href="#TransactionFeeSchedule">TransactionFeeSchedule</a></TD>
<TD>repeated</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>hederaFunctionality</TD>
<TD><a href="#HederaFunctionality">HederaFunctionality</a></TD>
<TD>&nbsp;</TD>
<TD><P>Specific Transaction or Query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>CryptoCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoTransfer</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoAddClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoDeletClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCall</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileCreate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileAppend</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileUpdate</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileDelete</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountBalance</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetAccountRecords</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractCallLocal</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>ContractGetBytecode</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetBySolidityID</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>GetByKey</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetClaim</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>CryptoGetStakers</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetContents</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>FileGetInfo</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>TransactionGetRecord</TD>
<TD></TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>feeData</TD>
<TD><a href="#FeeData">FeeData</a></TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged by Node for this functionality</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>networkdata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for network operations by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>servicedata</TD>
<TD><a href="#FeeComponents">FeeComponents</a></TD>
<TD>&nbsp;</TD>
<TD><P>Fee charged for provding service by Hedera</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P></P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>min</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>max</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>constant</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>vpt</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>rbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbs</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>tv</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>bpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>sbpr</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoAddClaim.proto">CryptoAddClaim.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="Claim"><span class="BigBadge">Message</span>Claim</H3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="CryptoAddClaimTransactionBody"><span class="BigBadge">Message</span>CryptoAddClaimTransactionBody</H3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoCreate.proto">CryptoCreate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoCreateTransactionBody"><span class="BigBadge">Message</span>CryptoCreateTransactionBody</H3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoDelete.proto">CryptoDelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoDeleteTransactionBody"><span class="BigBadge">Message</span>CryptoDeleteTransactionBody</H3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoDeleteClaim.proto">CryptoDeleteClaim.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoDeleteClaimTransactionBody"><span class="BigBadge">Message</span>CryptoDeleteClaimTransactionBody</H3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetAccountBalance.proto">CryptoGetAccountBalance.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoGetAccountBalanceQuery"><span class="BigBadge">Message</span>CryptoGetAccountBalanceQuery</H3>
<P> Get the balance of a cryptocurrency account. This returns only the balance, so it is a smaller and faster reply than CryptoGetAccountInfoQuery, which returns the balance plus additional information. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="CryptoGetAccountBalanceResponse"><span class="BigBadge">Message</span>CryptoGetAccountBalanceResponse</H3>
<P> Response when the client sends the node CryptoGetAccountBalanceQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is being described (this is useful with state proofs, for proving to a third party)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the current balance, in tinybars</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetAccountRecords.proto">CryptoGetAccountRecords.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoGetAccountRecordsQuery"><span class="BigBadge">Message</span>CryptoGetAccountRecordsQuery</H3>
<P> Get all the records for an account for any transfers into it and out of it, that were above the threshold, during the last 24 hours. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which the records should be retrieved</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="CryptoGetAccountRecordsResponse"><span class="BigBadge">Message</span>CryptoGetAccountRecordsResponse</H3>
<P> Response when the client sends the node CryptoGetAccountRecordsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that this record is for</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>records</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD>repeated</TD>
<TD><P>list of records, each with CryptoRecordBody as their body</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)_</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the transaction fee in the transaction</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of results of a CryptoTransferTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetClaim.proto">CryptoGetClaim.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoGetClaimQuery"><span class="BigBadge">Message</span>CryptoGetClaimQuery</H3>
<P> Get a single claim attached to an account, or return null if it does not exist. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim may be attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the claim</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoGetClaimResponse"><span class="BigBadge">Message</span>CryptoGetClaimResponse</H3>
<P> Response when the client sends the node CryptoGetClaimQuery. If the claim exists, there can be a state proof for that single claim. If the claim doesn't exist, then the state proof must be obtained for the account as a whole, which lists all the attached claims, which then proves that any claim not on the list must not exist. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>the claim (account, hash, keys), or null if there is no Claim with the given hash attached to the given account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetInfo.proto">CryptoGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoGetInfoQuery"><span class="BigBadge">Message</span>CryptoGetInfoQuery</H3>
<P> Get all the information about an account, including the balance. This does not get the list of account records. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="CryptoGetInfoResponse"><span class="BigBadge">Message</span>CryptoGetInfoResponse</H3>
<P> Response when the client sends the node CryptoGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountInfo</TD>
<TD><a href="#CryptoGetInfoResponse.AccountInfo">CryptoGetInfoResponse.AccountInfo</a></TD>
<TD>&nbsp;</TD>
<TD><P>info about the account (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node CryptoGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which this information applies</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>ID of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, then this account has been deleted, it will disappear when it expires, and all transactions for it will fail except the transaction to extend its expiration date</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>proxyReceived</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>total number of tinybars proxy staked to this account</P></TD>
</TR>

<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key for the account, which must sign in order to transfer out, or to modify the account in any way other than extending its expiration date.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the current number of tinybars in the account</P></TD>
</TR>

<TR>
<TD>generateSendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>account records will be created (and this account charged for them) for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>generateReceiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>account records will be created (and this account charged for them) for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, no transaction can transfer to this account unless signed by this account's key</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claims</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>repeated</TD>
<TD><P>all of the claims attached to the account (each of which is a hash along with the keys that authorized it and can delete it )</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="CryptoGetInfoResponse.AccountInfo"><span class="BigBadge">Message</span>CryptoGetInfoResponse.AccountInfo</H3>
<P> Response when the client sends the node CryptoGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which this information applies</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>ID of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, then this account has been deleted, it will disappear when it expires, and all transactions for it will fail except the transaction to extend its expiration date</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>proxyReceived</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>total number of tinybars proxy staked to this account</P></TD>
</TR>

<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key for the account, which must sign in order to transfer out, or to modify the account in any way other than extending its expiration date.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the current number of tinybars in the account</P></TD>
</TR>

<TR>
<TD>generateSendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>account records will be created (and this account charged for them) for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>generateReceiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>account records will be created (and this account charged for them) for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, no transaction can transfer to this account unless signed by this account's key</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claims</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>repeated</TD>
<TD><P>all of the claims attached to the account (each of which is a hash along with the keys that authorized it and can delete it )</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoGetStakers.proto">CryptoGetStakers.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="AllProxyStakers"><span class="BigBadge">Message</span>AllProxyStakers</H3>
<P> all of the accounts proxy staking to a given account, and the amounts proxy staked </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is being proxy staked to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyStaker</TD>
<TD><a href="#ProxyStaker">ProxyStaker</a></TD>
<TD>repeated</TD>
<TD><P>each of the proxy staking accounts, and the amount they are proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> information about a single account that is proxy staking </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of hbars that are currently proxy staked</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="CryptoGetStakersQuery"><span class="BigBadge">Message</span>CryptoGetStakersQuery</H3>
<P> Get all the accounts that are proxy staking to this account. For each of them, give the amount currently staked. This is not yet implemented, but will be in a future version of the API. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which the records should be retrieved</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="CryptoGetStakersResponse"><span class="BigBadge">Message</span>CryptoGetStakersResponse</H3>
<P> Response when the client sends the node CryptoGetStakersQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>stakers</TD>
<TD><a href="#AllProxyStakers">AllProxyStakers</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of accounts proxy staking to this account, and the amount each is currently proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> all of the accounts proxy staking to a given account, and the amounts proxy staked </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is being proxy staked to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyStaker</TD>
<TD><a href="#ProxyStaker">ProxyStaker</a></TD>
<TD>repeated</TD>
<TD><P>each of the proxy staking accounts, and the amount they are proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> information about a single account that is proxy staking </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of hbars that are currently proxy staked</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ProxyStaker"><span class="BigBadge">Message</span>ProxyStaker</H3>
<P> information about a single account that is proxy staking </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of hbars that are currently proxy staked</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoService.proto">CryptoService.proto</H2>
<a href="#title">Top</a>
</div>
<div class="file-heading">
<H2 id="CryptoTransfer.proto">CryptoTransfer.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="AccountAmount"><span class="BigBadge">Message</span>AccountAmount</H3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="CryptoTransferTransactionBody"><span class="BigBadge">Message</span>CryptoTransferTransactionBody</H3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="TransferList"><span class="BigBadge">Message</span>TransferList</H3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="CryptoUpdate.proto">CryptoUpdate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="CryptoUpdateTransactionBody"><span class="BigBadge">Message</span>CryptoUpdateTransactionBody</H3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Duration.proto">Duration.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="Duration"><span class="BigBadge">Message</span>Duration</H3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileAppend.proto">FileAppend.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileAppendTransactionBody"><span class="BigBadge">Message</span>FileAppendTransactionBody</H3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileCreate.proto">FileCreate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileCreateTransactionBody"><span class="BigBadge">Message</span>FileCreateTransactionBody</H3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileDelete.proto">FileDelete.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileDeleteTransactionBody"><span class="BigBadge">Message</span>FileDeleteTransactionBody</H3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileGetContents.proto">FileGetContents.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileGetContentsQuery"><span class="BigBadge">Message</span>FileGetContentsQuery</H3>
<P> Get the contents of a file. The content field is empty (no bytes) if the file is empty. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file whose contents are requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="FileGetContentsResponse"><span class="BigBadge">Message</span>FileGetContentsResponse</H3>
<P> Response when the client sends the node FileGetContentsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileContents</TD>
<TD><a href="#FileGetContentsResponse.FileContents">FileGetContentsResponse.FileContents</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID and contents (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node FileGetContentsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>The file whose contents are being returned</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes contained in the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="FileGetContentsResponse.FileContents"><span class="BigBadge">Message</span>FileGetContentsResponse.FileContents</H3>
<P> Response when the client sends the node FileGetContentsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>The file whose contents are being returned</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes contained in the file</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileGetInfo.proto">FileGetInfo.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileGetInfoQuery"><span class="BigBadge">Message</span>FileGetInfoQuery</H3>
<P> Get all of the information about a file, except for its contents. When a file expires, it no longer exists, and there will be no info about it, and the fileInfo field will be blank. If a transaction or smart contract deletes the file, but it has not yet expired, then the fileInfo field will be non-empty, the deleted field will be true, its size will be 0, and its contents will be empty. Note that each file has a FileID, but does not have a filename. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="FileGetInfoResponse"><span class="BigBadge">Message</span>FileGetInfoResponse</H3>
<P> Response when the client sends the node FileGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileInfo</TD>
<TD><a href="#FileGetInfoResponse.FileInfo">FileGetInfoResponse.FileInfo</a></TD>
<TD>&nbsp;</TD>
<TD><P>the information about the file (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node FileGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>size</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of bytes in contents</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>true if deleted but not yet expired</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>one of these keys must sign in order to modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="FileGetInfoResponse.FileInfo"><span class="BigBadge">Message</span>FileGetInfoResponse.FileInfo</H3>
<P> Response when the client sends the node FileGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>size</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of bytes in contents</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>true if deleted but not yet expired</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>one of these keys must sign in order to modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="FileService.proto">FileService.proto</H2>
<a href="#title">Top</a>
</div>
<div class="file-heading">
<H2 id="FileUpdate.proto">FileUpdate.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="FileUpdateTransactionBody"><span class="BigBadge">Message</span>FileUpdateTransactionBody</H3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="GetByKey.proto">GetByKey.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="EntityID"><span class="BigBadge">Message</span>EntityID</H3>
<P> the ID for a single entity (account, claim, file, or smart contract instance) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>entity</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a claim attached to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<H3 id="GetByKeyQuery"><span class="BigBadge">Message</span>GetByKeyQuery</H3>
<P> Get all accounts, claims, files, and smart contract instances whose associated keys include the given Key. The given Key must not be a contractID or a ThresholdKey. This is not yet implemented in the API, but will be in the future. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key to search for. It must not contain a contractID nor a ThresholdSignature.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="GetByKeyResponse"><span class="BigBadge">Message</span>GetByKeyResponse</H3>
<P> Response when the client sends the node GetByKeyQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>entities</TD>
<TD><a href="#EntityID">EntityID</a></TD>
<TD>repeated</TD>
<TD><P>list of entities that include this public key in their associated Key list</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> the ID for a single entity (account, claim, file, or smart contract instance) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>entity</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a claim attached to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="GetBySolidityID.proto">GetBySolidityID.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="GetBySolidityIDQuery"><span class="BigBadge">Message</span>GetBySolidityIDQuery</H3>
<P> Get the IDs in the format used by transactions, given the ID in the format used by Solidity. If the Solidity ID is for a smart contract instance, then both the ContractID and associated AccountID will be returned. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>solidityID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the ID in the format used by Solidity</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="GetBySolidityIDResponse"><span class="BigBadge">Message</span>GetBySolidityIDResponse</H3>
<P> Response when the client sends the node GetBySolidityIDQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a smart contract instance (if this is included, then the associated accountID will also be included)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Query.proto">Query.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="Query"><span class="BigBadge">Message</span>Query</H3>
<P> A single query, which is sent from the client to the node. This includes all possible queries. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>query</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>getByKey</TD>
<TD><a href="#GetByKeyQuery">GetByKeyQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all entities associated with a given key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get all accounts, claims, files, and smart contract instances whose associated keys include the given Key. The given Key must not be a contractID or a ThresholdKey. This is not yet implemented in the API, but will be in the future. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key to search for. It must not contain a contractID nor a ThresholdSignature.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>getBySolidityID</TD>
<TD><a href="#GetBySolidityIDQuery">GetBySolidityIDQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get the IDs in the format used in transactions, given the format used in Solidity</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get the IDs in the format used by transactions, given the ID in the format used by Solidity. If the Solidity ID is for a smart contract instance, then both the ContractID and associated AccountID will be returned. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>solidityID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the ID in the format used by Solidity</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallLocal</TD>
<TD><a href="#ContractCallLocalQuery">ContractCallLocalQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. It can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<TR>
<TD>maxResultSize</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractGetInfo</TD>
<TD><a href="#ContractGetInfoQuery">ContractGetInfoQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get information about a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get information about a smart contract instance. This includes the account that it uses, the file containing its bytecode, and the time when it will expire. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractGetBytecode</TD>
<TD><a href="#ContractGetBytecodeQuery">ContractGetBytecodeQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get bytecode used by a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get the bytecode for a smart contract instance </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ContractGetRecords</TD>
<TD><a href="#ContractGetRecordsQuery">ContractGetRecordsQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get all the records for a smart contract instance, for any function call (or the constructor call) during the last 24 hours, for which a Record was requested. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance for which the records should be retrieved</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptogetAccountBalance</TD>
<TD><a href="#CryptoGetAccountBalanceQuery">CryptoGetAccountBalanceQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get the current balance in a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get the balance of a cryptocurrency account. This returns only the balance, so it is a smaller and faster reply than CryptoGetAccountInfoQuery, which returns the balance plus additional information. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetAccountRecords</TD>
<TD><a href="#CryptoGetAccountRecordsQuery">CryptoGetAccountRecordsQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all the records that currently exist for transactions involving an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get all the records for an account for any transfers into it and out of it, that were above the threshold, during the last 24 hours. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which the records should be retrieved</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetInfo</TD>
<TD><a href="#CryptoGetInfoQuery">CryptoGetInfoQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all information about an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get all the information about an account, including the balance. This does not get the list of account records. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetClaim</TD>
<TD><a href="#CryptoGetClaimQuery">CryptoGetClaimQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get a single claim from a single account (or null if it doesn't exist)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get a single claim attached to an account, or return null if it does not exist. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim may be attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the claim</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetProxyStakers</TD>
<TD><a href="#CryptoGetStakersQuery">CryptoGetStakersQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all the accounts that proxy stake to a given account, and how much they proxy stake (not yet implemented in the current API)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get all the accounts that are proxy staking to this account. For each of them, give the amount currently staked. This is not yet implemented, but will be in a future version of the API. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which the records should be retrieved</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileGetContents</TD>
<TD><a href="#FileGetContentsQuery">FileGetContentsQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get the contents of a file (the bytes stored in it)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get the contents of a file. The content field is empty (no bytes) if the file is empty. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file whose contents are requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileGetInfo</TD>
<TD><a href="#FileGetInfoQuery">FileGetInfoQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get information about a file, such as its expiration date</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get all of the information about a file, except for its contents. When a file expires, it no longer exists, and there will be no info about it, and the fileInfo field will be blank. If a transaction or smart contract deletes the file, but it has not yet expired, then the fileInfo field will be non-empty, the deleted field will be true, its size will be 0, and its contents will be empty. Note that each file has a FileID, but does not have a filename. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionGetReceipt</TD>
<TD><a href="#TransactionGetReceiptQuery">TransactionGetReceiptQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get a receipt for a transaction (lasts 180 seconds)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus, then information about whether it succeeded or failed will be available until the end of the receipt period.  Before and after the receipt period, and for a transaction that was never submitted, the receipt is unknown.  This query is free (the payment field is left empty). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction for which the receipt is requested.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionGetRecord</TD>
<TD><a href="#TransactionGetRecordQuery">TransactionGetRecordQuery</a></TD>
<TD>&nbsp;</TD>
<TD><P>get a record for a transaction (lasts 1 hour)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Get the record for a transaction. If the transaction requested a record, then the record lasts for one hour, and a state proof is available for it. If the transaction created an account, file, or smart contract instance, then the record will contain the ID for what it created. If the transaction called a smart contract function, then the record contains the result of that call. If the transaction was a cryptocurrency transfer, then the record includes the TransferList which gives the details of that transfer. If the transaction didn't return anything that should be in the record, then the results field will be set to nothing. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction for which the record is requested.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="QueryHeader.proto">QueryHeader.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="QueryHeader"><span class="BigBadge">Message</span>QueryHeader</H3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="ResponseType"><span class="BigBadge">Enum</span>ResponseType</H3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Response.proto">Response.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="Response"><span class="BigBadge">Message</span>Response</H3>
<P> A single response, which is returned from the node to the client, after the client sent the node a query. This includes all responses. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>response</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>getByKey</TD>
<TD><a href="#GetByKeyResponse">GetByKeyResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all entities associated with a given key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node GetByKeyQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>entities</TD>
<TD><a href="#EntityID">EntityID</a></TD>
<TD>repeated</TD>
<TD><P>list of entities that include this public key in their associated Key list</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> the ID for a single entity (account, claim, file, or smart contract instance) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>entity</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a claim attached to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>getBySolidityID</TD>
<TD><a href="#GetBySolidityIDResponse">GetBySolidityIDResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get the IDs in the format used in transactions, given the format used in Solidity</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node GetBySolidityIDQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>a smart contract instance (if this is included, then the associated accountID will also be included)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallLocal</TD>
<TD><a href="#ContractCallLocalResponse">ContractCallLocalResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node ContractCallLocalQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>functionResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>the value returned by the function (if it completed and didn't fail)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractGetBytecodeResponse</TD>
<TD><a href="#ContractGetBytecodeResponse">ContractGetBytecodeResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get the bytecode for a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node ContractGetBytecodeQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bytecode</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytecode</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractGetInfo</TD>
<TD><a href="#ContractGetInfoResponse">ContractGetInfoResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get information about a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node ContractGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractInfo</TD>
<TD><a href="#ContractGetInfoResponse.ContractInfo">ContractGetInfoResponse.ContractInfo</a></TD>
<TD>&nbsp;</TD>
<TD><P>the information about this contract instance (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node ContractGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the cryptocurrency account owned by the contract instance, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>ID of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this contract instance (and its account) is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If the account is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>storage</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of bytes of storage being used by this instance (which affects the cost to extend the expiration time)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractGetRecordsResponse</TD>
<TD><a href="#ContractGetRecordsResponse">ContractGetRecordsResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>Get all existing records for a smart contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node ContractGetRecordsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance that this record is for</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>records</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD>repeated</TD>
<TD><P>list of records, each with contractCreateResult or contractCallResult as its body</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)_</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the transaction fee in the transaction</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of results of a CryptoTransferTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptogetAccountBalance</TD>
<TD><a href="#CryptoGetAccountBalanceResponse">CryptoGetAccountBalanceResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get the current balance in a cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node CryptoGetAccountBalanceQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is being described (this is useful with state proofs, for proving to a third party)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the current balance, in tinybars</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetAccountRecords</TD>
<TD><a href="#CryptoGetAccountRecordsResponse">CryptoGetAccountRecordsResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all the records that currently exist for transactions involving an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node CryptoGetAccountRecordsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that this record is for</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>records</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD>repeated</TD>
<TD><P>list of records, each with CryptoRecordBody as their body</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)_</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the transaction fee in the transaction</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of results of a CryptoTransferTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetInfo</TD>
<TD><a href="#CryptoGetInfoResponse">CryptoGetInfoResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all information about an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node CryptoGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountInfo</TD>
<TD><a href="#CryptoGetInfoResponse.AccountInfo">CryptoGetInfoResponse.AccountInfo</a></TD>
<TD>&nbsp;</TD>
<TD><P>info about the account (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node CryptoGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which this information applies</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractAccountID</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>ID of both the contract instance and the cryptocurrency account owned by the contract instance, in the format used by Solidity</P></TD>
</TR>

<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, then this account has been deleted, it will disappear when it expires, and all transactions for it will fail except the transaction to extend its expiration date</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>proxyReceived</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>total number of tinybars proxy staked to this account</P></TD>
</TR>

<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key for the account, which must sign in order to transfer out, or to modify the account in any way other than extending its expiration date.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>balance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the current number of tinybars in the account</P></TD>
</TR>

<TR>
<TD>generateSendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>account records will be created (and this account charged for them) for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>generateReceiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>account records will be created (and this account charged for them) for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, no transaction can transfer to this account unless signed by this account's key</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the expiration time will extend every this many seconds. If there are insufficient funds, then it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claims</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>repeated</TD>
<TD><P>all of the claims attached to the account (each of which is a hash along with the keys that authorized it and can delete it )</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetClaim</TD>
<TD><a href="#CryptoGetClaimResponse">CryptoGetClaimResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get a single claim from a single account (or null if it doesn't exist)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node CryptoGetClaimQuery. If the claim exists, there can be a state proof for that single claim. If the claim doesn't exist, then the state proof must be obtained for the account as a whole, which lists all the attached claims, which then proves that any claim not on the list must not exist. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>the claim (account, hash, keys), or null if there is no Claim with the given hash attached to the given account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoGetProxyStakers</TD>
<TD><a href="#CryptoGetStakersResponse">CryptoGetStakersResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get all the accounts that proxy stake to a given account, and how much they proxy stake</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node CryptoGetStakersQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>stakers</TD>
<TD><a href="#AllProxyStakers">AllProxyStakers</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of accounts proxy staking to this account, and the amount each is currently proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> all of the accounts proxy staking to a given account, and the amounts proxy staked </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is being proxy staked to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyStaker</TD>
<TD><a href="#ProxyStaker">ProxyStaker</a></TD>
<TD>repeated</TD>
<TD><P>each of the proxy staking accounts, and the amount they are proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> information about a single account that is proxy staking </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that is proxy staking</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of hbars that are currently proxy staked</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileGetContents</TD>
<TD><a href="#FileGetContentsResponse">FileGetContentsResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get the contents of a file (the bytes stored in it)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node FileGetContentsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileContents</TD>
<TD><a href="#FileGetContentsResponse.FileContents">FileGetContentsResponse.FileContents</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID and contents (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node FileGetContentsQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>The file whose contents are being returned</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes contained in the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileGetInfo</TD>
<TD><a href="#FileGetInfoResponse">FileGetInfoResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get information about a file, such as its expiration date</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node FileGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileInfo</TD>
<TD><a href="#FileGetInfoResponse.FileInfo">FileGetInfoResponse.FileInfo</a></TD>
<TD>&nbsp;</TD>
<TD><P>the information about the file (a state proof can be generated for this)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node FileGetInfoQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account for which information is requested</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>size</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of bytes in contents</P></TD>
</TR>

<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the current time at which this account is set to expire</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleted</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>true if deleted but not yet expired</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>one of these keys must sign in order to modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionGetReceipt</TD>
<TD><a href="#TransactionGetReceiptResponse">TransactionGetReceiptResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get a receipt for a transaction (lasts 180 seconds)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetReceiptQuery. If it created a new entity (account, file, or smart contract instance) then one of the three ID fields will be filled in with the ID of the new entity. Sometimes a single transaction will create more than one new entity, such as when a new contract instance is created, and this also creates the new account that it owned by that instance. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the receipt, indicating it reached consensus (and whether it succeeded or failed) or is currently unknown (because it hasn't reached consensus yet, or the transaction has expired already), and including the ID of any new account/file/instance created by that transaction.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionGetRecord</TD>
<TD><a href="#TransactionGetRecordResponse">TransactionGetRecordResponse</a></TD>
<TD>&nbsp;</TD>
<TD><P>get a record for a transaction (lasts 1 hour)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetRecordQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionRecord</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested record</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)_</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the transaction fee in the transaction</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of results of a CryptoTransferTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="ResponseHeader.proto">ResponseHeader.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="ResponseHeader"><span class="BigBadge">Message</span>ResponseHeader</H3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="SmartContractService.proto">SmartContractService.proto</H2>
<a href="#title">Top</a>
</div>
<div class="file-heading">
<H2 id="Timestamp.proto">Timestamp.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="Timestamp"><span class="BigBadge">Message</span>Timestamp</H3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TimestampSeconds"><span class="BigBadge">Message</span>TimestampSeconds</H3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="Transaction.proto">Transaction.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="Transaction"><span class="BigBadge">Message</span>Transaction</H3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="TransactionBody"><span class="BigBadge">Message</span>TransactionBody</H3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionGetReceipt.proto">TransactionGetReceipt.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TransactionGetReceiptQuery"><span class="BigBadge">Message</span>TransactionGetReceiptQuery</H3>
<P> Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus, then information about whether it succeeded or failed will be available until the end of the receipt period.  Before and after the receipt period, and for a transaction that was never submitted, the receipt is unknown.  This query is free (the payment field is left empty). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction for which the receipt is requested.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="TransactionGetReceiptResponse"><span class="BigBadge">Message</span>TransactionGetReceiptResponse</H3>
<P> Response when the client sends the node TransactionGetReceiptQuery. If it created a new entity (account, file, or smart contract instance) then one of the three ID fields will be filled in with the ID of the new entity. Sometimes a single transaction will create more than one new entity, such as when a new contract instance is created, and this also creates the new account that it owned by that instance. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the receipt, indicating it reached consensus (and whether it succeeded or failed) or is currently unknown (because it hasn't reached consensus yet, or the transaction has expired already), and including the ID of any new account/file/instance created by that transaction.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionGetRecord.proto">TransactionGetRecord.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TransactionGetRecordQuery"><span class="BigBadge">Message</span>TransactionGetRecordQuery</H3>
<P> Get the record for a transaction. If the transaction requested a record, then the record lasts for one hour, and a state proof is available for it. If the transaction created an account, file, or smart contract instance, then the record will contain the ID for what it created. If the transaction called a smart contract function, then the record contains the result of that call. If the transaction was a cryptocurrency transfer, then the record includes the TransferList which gives the details of that transfer. If the transaction didn't return anything that should be in the record, then the results field will be set to nothing. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#QueryHeader">QueryHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each query from the client to the node will contain the QueryHeader, which gives the requested response type, and includes a payment for the response. It will sometimes leave payment blank: it is blank for TransactionGetReceiptQuery. It can also be left blank when the responseType is costAnswer or costAnswerStateProof. But it needs to be filled in for all other cases. The idea is that an answer that is only a few bytes (or that was paid for earlier) can be given for free. But if the answer is something that requires many bytes or much computation (like a state proof), then it should be paid for. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>payment</TD>
<TD><a href="#Transaction">Transaction</a></TD>
<TD>&nbsp;</TD>
<TD><P>a signed CryptoTransferTransaction to pay the node a fee for handling this query</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single signed transaction, including all its signatures. The SignatureList will have a Signature for each Key in the transaction, either explicit or implicit, in the order that they appear in the transaction. For example, a CryptoTransfer will first have a Signature corresponding to the Key for the paying account, followed by a Signature corresponding to the Key for each account that is sending or receiving cryptocurrency in the transfer.  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>body</TD>
<TD><a href="#TransactionBody">TransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>the body of the transaction, which needs to be signed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A single transaction. All transaction types are possible here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID for this transaction, which includes the payer's account (the account paying the transaction fee). If two transactions have the same transactionID, they won't both have an effect</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>nodeAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account of the node that submits the client's transaction to the network</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee the client pays, which is split between the network and the node</P></TD>
</TR>

<TR>
<TD>transactionValidDuration</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp > transactionID.transactionValidStart + transactionValidDuration</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>generateRecord</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>should a record of this transaction be generated? (A receipt is always generated, but the record is optional)</P></TD>
</TR>

<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>any notes or descriptions that should be put into the record (max length 100)</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>adminDelete</TD>
<TD><a href="#AdminDeleteTransactionBody">AdminDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>Hedera multisig admin deletes a file or smart contract</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a file or smart contract - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to delete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<TR>
<TD>expirationTime</TD>
<TD><a href="#TimestampSeconds">TimestampSeconds</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which the "deleted" file should truly be permanently deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time,  with a resolution of one second (no nanoseconds). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminUndelete</TD>
<TD><a href="#AdminUndeleteTransactionBody">AdminUndeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>to undelete an entity deleted by AdminDelete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Undelete a file or smart contract that was deleted by AdminDelete - can only be done with a Hedera admin multisig. When it is deleted, it immediately disappears from the system as seen by the user, but is still stored internally until the expiration time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hedera admin multisig. When a smart contract is deleted, the cryptocurrency account within it continues to exist, and is not affected by the expiration time here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>id</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to undelete, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCall</TD>
<TD><a href="#ContractCallTransactionBody">ContractCallTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>call a function of a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Call a function of the given smart contract instance, giving it functionParameters as its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to call, in the format used in transactions</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the maximum amount of gas to use for the call</P></TD>
</TR>

<TR>
<TD>amount</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars sent (the function must be payable if this is nonzero)</P></TD>
</TR>

<TR>
<TD>functionParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>which function to call, and the parameters to pass to the function</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateInstance</TD>
<TD><a href="#ContractCreateTransactionBody">ContractCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The instance will run the bytecode stored in the given file, referenced either by FileID or by the transaction ID of the transaction that created the file. The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying account. Constructor inputs come from the given constructorParameters.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance. Note that if it is created with no admin keys, then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for that instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>gas</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>gas to run the constructor</P></TD>
</TR>

<TR>
<TD>initialBalance</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>initial number of tinybars to put into the cryptocurrency account associated with and owned by the smart contract</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this instance's account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>constructorParameters</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>parameters to pass to the constructor</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractUpdateInstance</TD>
<TD><a href="#ContractUpdateTransactionBody">ContractUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify info such as expiration date for a contract instance</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify a smart contract instance to have the given parameter values. Any null field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is needed on this transaction other than for the account paying for the transaction itself. But if any of the other fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things like the bytecode are immutable. But if there is an admin key, then they can be changed. For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before the bytecode can be changed. This can be used to add flexibility to the mangement of smart contract behavior. But this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its bytecode will be immutable. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract instance to update (this can't be changed)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>extend the expiration of the instance and its account to this time (no effect if it already is this time or later)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>adminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the state of the instance can be modified arbitrarily if this key signs a transaction to modify it. If this is null, then such modifications are not possible, and there is no administrator that can override the normal operation of this smart contract instance.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the instance will charge its account every this many seconds to renew for this long</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file containing the smart contract byte code. A copy will be made and held by the contract instance, and have the same expiration time as the instance. The file is referenced one of two ways:</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoAddClaim</TD>
<TD><a href="#CryptoAddClaimTransactionBody">CryptoAddClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>attach a new claim to an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Attach the given hash to the given account. The hash can be deleted by the keys used to transfer money from the account. The hash can also be deleted by any one of the deleteKeys (where that one may itself be a threshold key made up of multiple keys). Therefore, this acts as a revocation service for claims about the account. External authorities may issue certificates or credentials of some kind that make a claim about this account. The account owner can then attach a hash of that claim to the account. The transaction that adds the claim will be signed by the owner of the account, and also by all the authorities that are attesting to the truth of that claim. If the claim ever ceases to be true, such as when a certificate is revoked, then any one of the listed authorities has the ability to delete it. The account owner also has the ability to delete it at any time.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that the claim should be attached to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>claim</TD>
<TD><a href="#Claim">Claim</a></TD>
<TD>&nbsp;</TD>
<TD><P>a hash of some credential/certificate, along with the keys that authorized it and are allowed to delete it</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A hash (presumably of some kind of credential or certificate), along with a list  of threshold keys. Each of them must reach its threshold when signing the transaction, to attach this claim to this account. At least one of them must reach its threshold to delete this Claim from this account. This is intended to provide a revocation service: all the authorities agree to attach the hash, to attest to the fact that the credential or certificate is valid. Any one of the authorities can later delete the hash, to indicate that the credential has been revoked. In this way, any client can prove to a third party that any particular account has certain credentials, or to identity facts proved about it, and that none of them have been revoked yet. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to which the claim is attached</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>48 byte SHA-384 hash (presumably of some kind of credential or certificate)</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of keys: all must sign the transaction to attach the claim, and any one of them can later delete it. Each "key" can actually be a threshold key containing multiple other keys (including other threshold keys).</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoCreateAccount</TD>
<TD><a href="#CryptoCreateTransactionBody">CryptoCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new cryptocurrency account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 24 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>initialBalance</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the initial number of tinybars to put into the account</P></TD>
</TR>

<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>maxReceiveProxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>when another account tries to proxy stake to this account, accept it only if the proxyFraction from that other account is at most maxReceiveProxyFraction</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction withdrawing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>create an account record for any transaction depositing more than this many tinybars</P></TD>
</TR>

<TR>
<TD>receiverSigRequired</TD>
<TD>bool</TD>
<TD>&nbsp;</TD>
<TD><P>if true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals). This field is immutable; it cannot be changed by a CryptoUpdate transaction.</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account is charged to extend its expiration date every this many seconds. If it doesn't have enough, it extends as long as possible. If it is empty when it expires, then it is deleted.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDelete</TD>
<TD><a href="#CryptoDeleteTransactionBody">CryptoDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a cryptocurrency account (mark as deleted, and transfer hbars out)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its expiration extended in the normal way. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transferAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to receive all remaining hbars</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>deleteAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to delete</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoDeleteClaim</TD>
<TD><a href="#CryptoDeleteClaimTransactionBody">CryptoDeleteClaimTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>remove a claim from an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete a claim hash that was attached to the given account. This transaction is valid if signed by all the keys used for transfers out of the account. It is also valid if signed by any single ThresholdKeys in the deleteKeys list for this hash. See CryptoAddClaimTransaction for more information about claim hashes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToDeleteFrom</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that should have a claim deleted</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>hashToDelete</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash in the claim to delete (a SHA-384 hash, 48 bytes)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoTransfer</TD>
<TD><a href="#CryptoTransferTransactionBody">CryptoTransferTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>transfer hbars between accounts</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Transfer cryptocurrency from some accounts to other accounts. The accounts list can contain up to 10 accounts. The amounts list must be the same length as the accounts list. Each negative amount is withdrawn from the corresponding account (a sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero. Each amount is a number of tinyBars (there are 100,000,000 tinyBars in one Hbar). If any sender account fails to have sufficient hbars to do the withdrawal, then the entire transaction fails, and none of those transfers occur, though the transaction fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures are in the same order as the accounts, skipping those accounts that don't need a signature. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>transfers</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>accounts and amounts to transfer</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cryptoUpdateAccount</TD>
<TD><a href="#CryptoUpdateTransactionBody">CryptoUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for an account</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Change properties for the given account. Any null field is ignored (left unchanged). The receiverSigRequired boolean field cannot be changed; it is immutable. This transaction must be signed by the existing key for this account. If the transaction is changing the key field, then the transaction must be signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. When extending the expiration date, the cost is affected by the size of the list of attached claims, and of the keys associated with the claims and the account. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountIDToUpdate</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account to modify</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>key</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyAccountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking at the given fraction, or if it is not currently running a node, then it will behave as if both proxyAccountID and proxyFraction were null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>proxyFraction</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>payments earned from proxy staking are shared between the node and this account, with proxyFraction / 10000 going to this account</P></TD>
</TR>

<TR>
<TD>sendRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for sending</P></TD>
</TR>

<TR>
<TD>receiveRecordThreshold</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the new threshold for generating records for receiving</P></TD>
</TR>

<TR>
<TD>autoRenewPeriod</TD>
<TD><a href="#Duration">Duration</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new frequency with which it will automatically extend the expiration period</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P>  The length of a period of time. This is an identical data structure to the protobuf Duration.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/duration.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of seconds</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds that is added to seconds to get the length of the duration</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new expiration time to extend to (ignored if equal to or before the current one)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileAppend</TD>
<TD><a href="#FileAppendTransactionBody">FileAppendTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>add bytes to the end of the contents of a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Append the given contents to the end of the file. If a file is too big to create with a single FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times to create the entire file. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to append to</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes to append to the contents of the file</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileCreate</TD>
<TD><a href="#FileCreateTransactionBody">FileCreateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>create a new file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Create a new file, containing the given contents.  It is referenced by its FileID, and does not have a filename, so it is important to get the FileID. After the file is created, the FileID for it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the time at which this file should expire (unless FileUpdateTransaction is used before then to extend its life)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>all these keys must sign to create or modify the file. Any one of them can sign to delete the file.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the bytes that are the contents of the file</P></TD>
</TR>

<TR>
<TD>shardID</TD>
<TD><a href="#ShardID">ShardID</a></TD>
<TD>&nbsp;</TD>
<TD><P>shard in which to create this</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>realmID</TD>
<TD><a href="#RealmID">RealmID</a></TD>
<TD>&nbsp;</TD>
<TD><P>realm in which to create this (leave this null to create a new realm)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>newRealmAdminKey</TD>
<TD><a href="#Key">Key</a></TD>
<TD>&nbsp;</TD>
<TD><P>if realmID is null, then this the admin key for the new realm that will be created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileDelete</TD>
<TD><a href="#FileDeleteTransactionBody">FileDeleteTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>delete a file (remove contents and mark as deleted until it expires)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Delete the given file. After deletion, it will be marked as deleted and will have no contents. But information about it will continue to exist until it expires. A list of keys  was given when the file was created. All the keys on that list must sign transactions to create or modify the file, but any single one of them can be used to delete the file. Each "key" on that list may itself be a threshold key containing other keys (including other threshold keys). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to delete. It will be marked as deleted until it expires. Then it will disappear.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileUpdate</TD>
<TD><a href="#FileUpdateTransactionBody">FileUpdateTransactionBody</a></TD>
<TD>&nbsp;</TD>
<TD><P>modify information such as the expiration date for a file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Modify some of the metadata for a file. Any null field is ignored (left unchanged). Any field that is null is left unchanged. If contents is non-null, then the file's contents will be replaced with the given bytes. This transaction must be signed by all the keys for that file. If the transaction is modifying the keys field, then it must be signed by all the keys in both the old list and the new list. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file to update</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>expirationTime</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the new time at which it should expire (ignored if not later than the current value)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the keys that can modify or delete the file</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A list of keys </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>keys</TD>
<TD><a href="#Key">Key</a></TD>
<TD>repeated</TD>
<TD><P>list of keys</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>key</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>smart contract instance that is authorized as if it had signed with a key</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 public key</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 public key</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA with the p-384 curve public key</P></TD>
</TR>

<TR>
<TD>thresholdKey</TD>
<TD><a href="#ThresholdKey">ThresholdKey</a></TD>
<TD>&nbsp;</TD>
<TD><P>a threshold N followed by a list of M keys, any N of which are required to form a valid signature</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>threshold</TD>
<TD>uint32</TD>
<TD>&nbsp;</TD>
<TD><P>a valid signature set must have at least this many signatures</P></TD>
</TR>

<TR>
<TD>keys</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>list of all the keys that can sign</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>keyList</TD>
<TD><a href="#KeyList">KeyList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of Keys.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contents</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the new file contents. All the bytes in the old contents are discarded.</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>the signatures on the body, to authorize the transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The signatures corresponding to a KeyList of the same length  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#Signature">Signature</a></TD>
<TD>repeated</TD>
<TD><P>each signature corresponds to a Key in the KeyList</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.</P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>signature</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contract</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>smart contract virtual signature (always length zero)</P></TD>
</TR>

<TR>
<TD>ed25519</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ed25519 signature</P></TD>
</TR>

<TR>
<TD>RSA_3072</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>RSA-3072 signature</P></TD>
</TR>

<TR>
<TD>ECDSA_384</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>ECDSA p-384 signature</P></TD>
</TR>

<TR>
<TD>thresholdSignature</TD>
<TD><a href="#ThresholdSignature">ThresholdSignature</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>sigs</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>signatureList</TD>
<TD><a href="#SignatureList">SignatureList</a></TD>
<TD>&nbsp;</TD>
<TD><P>a list of M signatures, each corresponding to a Key in a KeyList of the same length.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
Self Reference
</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response, asking for cost, state proof, both, or neither</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction for which the record is requested.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="TransactionGetRecordResponse"><span class="BigBadge">Message</span>TransactionGetRecordResponse</H3>
<P> Response when the client sends the node TransactionGetRecordQuery </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>header</TD>
<TD><a href="#ResponseHeader">ResponseHeader</a></TD>
<TD>&nbsp;</TD>
<TD><P>standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Every query receives a response containing the QueryResponseHeader. Either or both of the cost and stateProof fields may be blank, if the responseType didnt ask for the cost or stateProof. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>result of fee transaction precheck, saying it passed, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>responseType</TD>
<TD><a href="#ResponseType">ResponseType</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested response is repeated back here, for convenience</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The client uses the ResponseType to request that the node send it just the answer, or both the answer and a state proof. It can also ask for just the cost for getting the answer or both. If the payment in the query fails the precheck, then the response may have some fields blank. The state proof is only available for some types of information. It is available for a Record, but not a receipt. It is available for the information in each kind of *GetInfo request. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>ANSWER_ONLY</TD>
<TD></TD>
<TD><P>Response returns answer</P></TD>
</TR>

<TR>
<TD>ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns both answer and state proof</P></TD>
</TR>

<TR>
<TD>COST_ANSWER</TD>
<TD></TD>
<TD><P>Response returns the cost of answer</P></TD>
</TR>

<TR>
<TD>COST_ANSWER_STATE_PROOF</TD>
<TD></TD>
<TD><P>Response returns the total cost of answer and state proof</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>cost</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the fee that would be charged to get the requested information (if a cost was requested)</P></TD>
</TR>

<TR>
<TD>stateProof</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the state proof for this information (if a state proof was requested, and is available)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionRecord</TD>
<TD><a href="#TransactionRecord">TransactionRecord</a></TD>
<TD>&nbsp;</TD>
<TD><P>the requested record</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)_</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the transaction fee in the transaction</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of results of a CryptoTransferTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionReceipt.proto">TransactionReceipt.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TransactionReceipt"><span class="BigBadge">Message</span>TransactionReceipt</H3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

<H3 id="TransactionStatus"><span class="BigBadge">Enum</span>TransactionStatus</H3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionRecord.proto">TransactionRecord.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="TransactionRecord"><span class="BigBadge">Message</span>TransactionRecord</H3>
<P> Response when the client sends the node TransactionGetRecordResponse </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>receipt</TD>
<TD><a href="#TransactionReceipt">TransactionReceipt</a></TD>
<TD>&nbsp;</TD>
<TD><P>the status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>status</TD>
<TD><a href="#TransactionStatus">TransactionStatus</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction succeeded or failed (or is unknown)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The consensus result for a transaction, which might not be currently known, or may  succeed or fail. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>UNKNOWN</TD>
<TD></TD>
<TD><P>hasn't yet reached consensus, or has already expired</P></TD>
</TR>

<TR>
<TD>SUCCESS</TD>
<TD></TD>
<TD><P>the transaction succeeded</P></TD>
</TR>

<TR>
<TD>FAIL_INVALID</TD>
<TD></TD>
<TD><P>the transaction failed because it is invalid</P></TD>
</TR>

<TR>
<TD>FAIL_FEE</TD>
<TD></TD>
<TD><P>the transaction fee was insufficient</P></TD>
</TR>

<TR>
<TD>FAIL_BALANCE</TD>
<TD></TD>
<TD><P>the paying account had insufficient cryptocurrency</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account ID, if a new account was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>fileID</TD>
<TD><a href="#FileID">FileID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the file ID, if a new file was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a file  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>fileNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the contract ID, if a new smart contract instance was created</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionHash</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the hash of the Transaction that executed (not the hash of any Transaction that failed for having a duplicate TransactionID)_</P></TD>
</TR>

<TR>
<TD>consensusTimestamp</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the consensus timestamp (or null if didn't reach consensus yet)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionID</TD>
<TD><a href="#TransactionID">TransactionID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the ID of the transaction this record represents</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the account that paid for this transaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transactionValidStart</TD>
<TD><a href="#Timestamp">Timestamp</a></TD>
<TD>&nbsp;</TD>
<TD><P>the transaction is invalid if consensusTimestamp < transactionID.transactionStartValid</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the comments in https:github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto) </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>seconds</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>number of complete seconds since the start of the epoch</P></TD>
</TR>

<TR>
<TD>nanos</TD>
<TD>int32</TD>
<TD>&nbsp;</TD>
<TD><P>number of nanoseconds since the start of the last second</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>memo</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>the memo that was submitted as part of the transaction (max 100 bytes)</P></TD>
</TR>

<TR>
<TD>transactionFee</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>the transaction fee in the transaction</P></TD>
</TR>

<TR>
<TD>body</TD>
<TD>oneof</TD>
<TD>&nbsp;</TD>
<TD><P></P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractCallResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract function (if it completed and didn't fail) from ContractCallTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCreateResult</TD>
<TD><a href="#ContractFunctionResult">ContractFunctionResult</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of the value returned by the smart contract constructor (if it completed and didn't fail) from ContractCreateTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The result returned by a call to a smart contract function. This is part of the response to a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance transaction. The ContractCreateInstance transaction record has the results of the call to the constructor. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>the smart contract instance whose function was called</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>contractCallResult</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>the result returned by the function</P></TD>
</TR>

<TR>
<TD>errorMessage</TD>
<TD>string</TD>
<TD>&nbsp;</TD>
<TD><P>message In case there was an error during smart contract execution</P></TD>
</TR>

<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for record</P></TD>
</TR>

<TR>
<TD>gasUsed</TD>
<TD>uint64</TD>
<TD>&nbsp;</TD>
<TD><P>units of gas used  to execute contract</P></TD>
</TR>

<TR>
<TD>logInfo</TD>
<TD><a href="#ContractLoginfo">ContractLoginfo</a></TD>
<TD>repeated</TD>
<TD><P>the log info for events returned by the function</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The log information for an event returned by a smart contract function call. One function call may return several such events. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>contractID</TD>
<TD><a href="#ContractID">ContractID</a></TD>
<TD>&nbsp;</TD>
<TD><P>address of a contract that emitted the event</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for a smart contract instance  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>contractNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>bloom</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>bloom filter for a particular log</P></TD>
</TR>

<TR>
<TD>topic</TD>
<TD>bytes</TD>
<TD>repeated</TD>
<TD><P>topics of a particular event</P></TD>
</TR>

<TR>
<TD>data</TD>
<TD>bytes</TD>
<TD>&nbsp;</TD>
<TD><P>event data</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>transferList</TD>
<TD><a href="#TransferList">TransferList</a></TD>
<TD>&nbsp;</TD>
<TD><P>record of results of a CryptoTransferTransaction</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> a list of accounts and amounts to transfer out of each account (negative) or into it (positive). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountAmounts</TD>
<TD><a href="#AccountAmount">AccountAmount</a></TD>
<TD>repeated</TD>
<TD><P>list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> An account, and the amount that it sends or receives during a cryptocurrency transfer. </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>accountID</TD>
<TD><a href="#AccountID">AccountID</a></TD>
<TD>&nbsp;</TD>
<TD><P>an account that sends or receives cryptocurrency</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> The ID for an a cryptocurrency account  </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>shardNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the shard number (nonnegative)</P></TD>
</TR>

<TR>
<TD>realmNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>the realm number (nonnegative)</P></TD>
</TR>

<TR>
<TD>accountNum</TD>
<TD>int64</TD>
<TD>&nbsp;</TD>
<TD><P>a nonnegative number unique within its realm</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<TR>
<TD>amount</TD>
<TD><a href="#sint64">sint64</a></TD>
<TD>&nbsp;</TD>
<TD><P>number of tinybars that the account sends (negative) or receives (positive)</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>
<tbody>
</TABLE>

<div class="file-heading">
<H2 id="TransactionResponse.proto">TransactionResponse.proto</H2>
<a href="#title">Top</a>
</div>
<H3 id="NodeTransactionPrecheckCode"><span class="BigBadge">Enum</span>NodeTransactionPrecheckCode</H3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

<H3 id="TransactionResponse"><span class="BigBadge">Message</span>TransactionResponse</H3>
<P> When the client sends the node a transaction of any kind, the node replies with this, which simply says that the transaction passed the precheck (so the node will submit it to the network) or it failed (so it won't). To learn the consensus result, the client should later obtain a receipt (free), or can buy a more detailed record (not free). </P>
<table class="field-table">
<thead>
<TR>
<TD>Field</TD>
<TD>Type</TD>
<TD>Label</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>nodeTransactionPrecheckCode</TD>
<TD><a href="#NodeTransactionPrecheckCode">NodeTransactionPrecheckCode</a></TD>
<TD>&nbsp;</TD>
<TD><P>whether the transaction passed the precheck, or why it failed</P></TD>
</TR>

<TR>
<TD>&nbsp;</TD>
<TD colspan=3>
<P> When the node receives a transaction from a client, it performs a precheck, to see if if the transaction is correctly formed, and if the account has sufficient cryptocurrency to pay the transaction fee. If it passes the precheck, then the node will send it to the network for processing.  The node will always reply to a transaction with the TransactionResponse, which indicates whether it passed the precheck, or why it failed. </P>
<table class="enum-table">
<thead>
<TR>
<TD>Enum Name</TD>
<TD>Enum Value</TD>
<TD>Description</TD>
</TR>
</thead>
<tbody>
<TR>
<TD>OK</TD>
<TD></TD>
<TD><P>the transaction passed the precheck</P></TD>
</TR>

<TR>
<TD>INVALID_TRANSACTION</TD>
<TD></TD>
<TD><P>the transaction had incorrect syntax or other errors</P></TD>
</TR>

<TR>
<TD>INVALID_ACCOUNT</TD>
<TD></TD>
<TD><P>the payer account or node account isn't a valid account number</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_FEE</TD>
<TD></TD>
<TD><P>the transaction fee is insufficient for this type of transaction</P></TD>
</TR>

<TR>
<TD>INSUFFICIENT_BALANCE</TD>
<TD></TD>
<TD><P>the payer account has insufficient cryptocurrency to pay the transaction fee</P></TD>
</TR>

<TR>
<TD>DUPLICATE</TD>
<TD></TD>
<TD><P>this transaction ID is a duplicate of one that was submitted to this node or reached consensus in the last 180 seconds (receipt period)</P></TD>
</TR>

<TR>
<TD>BUSY</TD>
<TD></TD>
<TD><P>If API is throttled out</P></TD>
</TR>

<TR>
<TD>NOT_SUPPORTED</TD>
<TD></TD>
<TD><P>not supported API</P></TD>
</TR>

<tbody>
</TABLE>

</TD>
</TR>
<tbody>
</TABLE>

</div></div></body>